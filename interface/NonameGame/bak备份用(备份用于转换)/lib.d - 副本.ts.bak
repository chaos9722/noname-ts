declare interface Lib {
		configprefix:string;
		versionOL:number;
		/** 更新地址 */
		updateURL:string;
		/** 更新的镜像地址 */
		mirrorURL:string;
		/** 联机地址 */
		hallURL:string;
		/** 网络资源地址 */
		assetURL:string;
		changeLog:any[];
		updates:any[];
		canvasUpdates:any[];
		video:any[];
		skilllist:any[];
		connectBanned:any[];
		characterIntro:any;
		characterTitle:any;
		characterPack:any;
		characterFilter:any;
		characterSort:any;
		cardPack:any;
		onresize:any[];
		onphase:any[];
		onwash:any[];
		onover:any[];
		ondb:any[];
		ondb2:any[];
		chatHistory:any[];
		arenaReady:any[];
		onfree:any[];
		inpile:any[];
		extensions:any[];
		extensionPack:any;
		cardType:any;
		hook:{
			globaltrigger:any,
			globalskill:any;
		};
		hookmap:any;
		imported:any;
		layoutfixed:['chess','tafang','stone'];
        characterDialogGroup:SMap<(name,capt) => void>;
        listenEnd:(node:any)=>void;
        /** 菜单配置 */
		configMenu:{
            /** 通用 */
			general:{
				name:string,
				config:{
                    /** 流畅模式 */
                    low_performance:SelectConfigData,
                    /** 兼容模式 */
                    compatiblemode:SelectConfigData,
                    /** 确认退出 */
                    confirm_exit:SelectConfigData,
                    /** 屏幕常亮 */
                    keep_awake:SelectConfigData,
                    /** 自动确认 */
                    auto_confirm:SelectConfigData,
                    /** 不无懈自己 */
                    wuxie_self:SelectConfigData,
                    /** 不对敌方出桃 */
                    tao_enemy:SelectConfigData,
                    /** 启用拖拽 */
                    enable_drag:SelectConfigData,
                    /** 拖拽指示线 */
                    enable_dragline:SelectConfigData,
                    /** 拖拽指示线 */
                    enable_touchdragline:SelectConfigData,
                    /** 触屏模式 */
                    touchscreen:SelectConfigData,
                    /** 滑动手势 */
                    swipe:SelectConfigData,
                    /** 下划操作 */
                    swipe_down:SelectConfigData,
                    /** 上划操作 */
                    swipe_up:SelectConfigData,
                    /** 左划操作 */
                    swipe_left:SelectConfigData,
                    /** 右划操作 */
                    swipe_right:SelectConfigData,
                    /** 触屏按钮操作 */
                    round_menu_func:SelectConfigData,
                    /** 显示开始界面 */
                    show_splash:SelectConfigData,
                    /** 游戏速度 */
                    game_speed:SelectConfigData,
                    /** 限制结算速度 */
                    sync_speed:SelectConfigData,
                    /** 开启震动 */
                    enable_vibrate:SelectConfigData,
                    /** 右键操作 */
                    right_click:SelectConfigData,
                    /** 长按显示信息 */
                    longpress_info:SelectConfigData,
                    /** 右键显示信息 */
                    right_info:SelectConfigData,
                    /** 悬停显示信息 */
                    hover_all:SelectConfigData,
                    /** 悬停手牌显示信息 */
                    hover_handcard:SelectConfigData,
                    /** 悬停菜单弹出时间 */
                    hoveration:SelectConfigData,
                    /** 双击显示武将资料 */
                    doubleclick_intro:SelectConfigData,
                    /** 保存录像 */
                    video:SelectConfigData,
                    /** 最长载入时间 */
                    max_loadtime:SelectConfigData,
                    /** 滚轮控制手牌 */
                    mousewheel:SelectConfigData,
                    /** 自动检查游戏更新 */
                    auto_check_update:SelectConfigData,
                    /** 开发者模式 */
                    dev:SelectConfigData,
                    /** 出错时停止游戏 */
					errstop:SelectConfigData,
					update:(config,map) => void,
				}
            };
            /** 外观 */
			appearence:{
				name:string,
				config:{
                    /** 主题 */
                    theme:SelectConfigData,
                    /** 布局 */
                    layout:SelectConfigData,
                    /** 角色高度 long */
					player_height:SelectConfigData,
                    /** 角色高度 short */
                    player_height_nova:SelectConfigData,
                    /** 界面缩放 */
                    ui_zoom:SelectConfigData,
                    /** 游戏背景 */
                    image_background:SelectConfigData,
                    /** 随机背景 */
                    image_background_random:SelectConfigData,
                    /** 背景模糊 */
                    image_background_blur:SelectConfigData,
                    /** 触屏布局 */
                    phonelayout:SelectConfigData,
                    /** 开启换肤 */
                    change_skin:SelectConfigData,
                    /** 自动换肤 */
                    change_skin_auto:SelectConfigData,
                    /** 卡牌样式 */
                    card_style:SelectConfigData,
                    /** 卡背样式 */
                    cardback_style:SelectConfigData,
                    /** 体力条样式 */
                    hp_style:SelectConfigData,
                    /** 角色背景 */
                    player_style:SelectConfigData,
                    /** 角色边框 */
                    border_style:SelectConfigData,
                    /** 边框升级方式 */
                    autoborder_count:SelectConfigData,
                    /** 基础边框颜色 */
                    autoborder_start:SelectConfigData,
                    /** 边框宽度 */
                    player_border:SelectConfigData,
                    /** 菜单背景 */
                    menu_style:SelectConfigData,
                    /** 按钮背景 */
                    control_style:SelectConfigData,
                    /** 菜单上部高度 */
                    custom_button_system_top:SelectConfigData,
                    /** 菜单下部高度 */
                    custom_button_system_bottom:SelectConfigData,
                    /** 技能上部高度 */
                    custom_button_control_top:SelectConfigData,
                    /** 技能下部高度 */
                    custom_button_control_bottom:SelectConfigData,
                    /** 圆角大小 */
                    radius_size:SelectConfigData,
                    /** 当前回合角色高亮 */
                    glow_phase:SelectConfigData,
                    /** 折叠手牌 */
                    fold_card:SelectConfigData,
                    /** 折叠模式菜单 */
                    fold_mode:SelectConfigData,
                    /** 分离选项条 */
                    seperate_control:SelectConfigData,
                    /** 模糊效果 */
                    blur_ui:SelectConfigData,
                    /** 玻璃主题 */
                    glass_ui:SelectConfigData,
                    /** 伤害抖动 */
                    damage_shake:SelectConfigData,
                    /** 按钮效果 */
                    button_press:SelectConfigData,
                    /** 喝酒效果 */
                    jiu_effect:SelectConfigData,
                    /** 游戏特效 */
                    animation:SelectConfigData,
                    /** 技能特效 */
                    skill_animation_type:SelectConfigData,
                    /** 阵亡效果 */
                    die_move:SelectConfigData,
                    /** 目标效果 */
                    target_shake:SelectConfigData,
                    /** 翻面文字 */
                    turned_style:SelectConfigData,
                    /** 横置样式 */
                    link_style2:SelectConfigData,
                    /** 手牌显示 */
                    cardshape:SelectConfigData,
                    /** 装备显示 */
                    textequip:SelectConfigData,
                    /** 选将样式 */
                    buttoncharacter_style:SelectConfigData,
                    /** 鼠标指针 */
                    cursor_style:SelectConfigData,
                    /** 人名字体 */
                    name_font:SelectConfigData,
                    /** 身份字体 */
                    identity_font:SelectConfigData,
                    /** 卡牌字体 */
                    cardtext_font:SelectConfigData,
                    /** 界面字体 */
					global_font:SelectConfigData,
					update:(config,map) => void,
				}
            },
            /** 显示 */
			view:{
				name:'显示',
				config:{
                    /** 出牌记录栏 */
                    show_history:SelectConfigData,
                    /** 自动弹出记录 */
                    pop_logv:SelectConfigData,
                    /** 历史记录栏 */
                    show_log:SelectConfigData,
                    /** 自动清除历史记录 */
                    clear_log:SelectConfigData,
                    /** 历史记录高亮 */
                    log_highlight:SelectConfigData,
                    /** 显示时间（在屏幕顶部显示当前时间） */
					show_time:SelectConfigData,
                    /** 显示时间（在触屏按钮处显示当前时间） */
                    show_time2:SelectConfigData,
                    /** 表盘样式 */
                    watchface:SelectConfigData,
                    /** 显示游戏时间 */
                    show_time3:SelectConfigData,
                    /** 显示状态栏(安卓) */
					show_statusbar_android:SelectConfigData,
                    /** 显示状态栏（ios） */
                    show_statusbar_ios:SelectConfigData,
                    /** 显示出牌信息 */
                    show_card_prompt:SelectConfigData,
                    /** 隐藏基本牌信息 */
                    hide_card_prompt_basic:SelectConfigData,
                    /** 隐藏装备牌信息 */
                    hide_card_prompt_equip:SelectConfigData,
                    /** 显示阶段信息 */
                    show_phase_prompt:SelectConfigData,
                    /** 出牌阶段提示 */
                    show_phaseuse_prompt:SelectConfigData,
                    /** 自动弹出选项 */
                    auto_popped_config:SelectConfigData,
                    /** 自动弹出历史 */
                    auto_popped_history:SelectConfigData,
                    /** 显示触屏按钮 */
                    show_round_menu:SelectConfigData,
                    /** 记住按钮位置 */
                    remember_round_button:SelectConfigData,
                    /** 记住对话框位置 */
                    remember_dialog:SelectConfigData,
                    /** 标记身份操作 */
                    mark_identity_style:SelectConfigData,
                    /** 自由选将显示 */
                    character_dialog_tool:SelectConfigData,
                    /** 最近使用武将 */
                    recent_character_number:SelectConfigData,
                    /** 触屏装备选择 */
                    popequip:SelectConfigData,
                    /** 触屏筛选按钮 */
                    filternode_button:SelectConfigData,
                    /** 显示武将资料 */
                    show_charactercard:SelectConfigData,
                    /** 显示添加收藏 */
                    show_favourite:SelectConfigData,
                    /** 显示模式收藏 */
                    show_favmode:SelectConfigData,
                    /** 显示收藏菜单 */
                    show_favourite_menu:SelectConfigData,
                    /** 显示禁将菜单 */
                    show_ban_menu:SelectConfigData,
                    /** 显示距离信息 */
                    right_range:SelectConfigData,
                    /** 隐藏卡牌背景 */
                    hide_card_image:SelectConfigData,
                    /** 显示角色名称 */
                    show_name:SelectConfigData,
                    /** 显示重来按钮 */
                    show_replay:SelectConfigData,
                    /** 显示身份按钮 */
                    show_playerids:SelectConfigData,
                    /** 显示暂停按钮 */
                    show_pause:SelectConfigData,
                    /** 显示托管按钮 */
                    show_auto:SelectConfigData,
                    /** 显示音量按钮 */
                    show_volumn:SelectConfigData,
                    /** 显示牌堆按钮 */
                    show_cardpile:SelectConfigData,
                    /** 显示剩余牌数 */
                    show_cardpile_number:SelectConfigData,
                    /** 显示手牌按钮 */
                    show_handcardbutton:SelectConfigData,
                    /** 显示投降按钮 */
                    show_giveup:SelectConfigData,
                    /** 显示无懈按钮 */
                    show_wuxie:SelectConfigData,
                    /** 无懈按钮靠左 */
                    wuxie_right:SelectConfigData,
                    /** 暂停时显示弃牌堆 */
                    show_discardpile:SelectConfigData,
                    /** 显示制作扩展 */
                    show_extensionmaker:SelectConfigData,
                    /** 显示分享扩展 */
                    show_extensionshare:SelectConfigData,
                    update:(config,map) => void
				}
            },
            /** 音效 */
			audio:{
				name:string,
				config:{
                    /** 背景音乐 */
                    background_music:SelectConfigData,
                    /** 导入音乐 */
                    import_music:SelectConfigData,
                    /** 游戏音效 */
                    background_audio:SelectConfigData,
                    /** 人物配音 */
                    background_speak:SelectConfigData,
                    /** 装备配音 */
                    equip_audio:SelectConfigData,
                    /** 音效音量 */
                    volumn_audio:SelectConfigData,
                    /** 音乐音量 */
                    volumn_background:SelectConfigData,
                    update:(config,map) => void
				}
            },
            /** 技能 */
			skill:{
				name:string,
				config:{
					update:(config,map) => void
				}
            },
            /** 其它 */
			others:{
				name:string,
				config:{
                    /** 重置游戏设置 */
                    reset_game:SelectConfigData,
                    /** 重置隐藏内容 */
                    reset_hiddenpack:SelectConfigData,
                    /** 重置新手向导 */
                    reset_tutorial:SelectConfigData,
                    /** 导入游戏设置 */
                    import_data:SelectConfigData,
                    /** 导入游戏设置按钮 */
                    import_data_button:SelectConfigData,
                    /** 导出游戏设置 */
                    export_data:SelectConfigData,
                    /** 重新下载游戏 */
					redownload_game:SelectConfigData,
					update:(config,map) => void
				}
			}
        },
        /** 扩展菜单 */
		extensionMenu:{
            /** 牌堆补充 */
            cardpile:ExtensionMenuConfigData,
            /** 诸神降临 */
            boss:ExtensionMenuConfigData,
            /** 五行生克 */
            wuxing:ExtensionMenuConfigData,
            /** 富甲天下 */
            coin:ExtensionMenuConfigData,
        },
        /** 开始模式选择菜单 */
		mode:{
            /** 身份局 */
			identity:{
				name:string,
				connect:{
                    update:(config,map) => void,
                    /** 游戏模式 */
                    connect_identity_mode:SelectConfigData,
                    /** 游戏人数 */
                    connect_player_number:SelectConfigData,
                    /** 明忠卡牌替换 */
                    connect_zhong_card:SelectConfigData,
                    /** 双内奸 */
                    connect_double_nei:SelectConfigData,
                    /** 双将模式 */
                    connect_double_character:SelectConfigData,
                    /** 特殊身份 */
                    connect_special_identity:SelectConfigData,
                    /** 加强主公 */
					connect_enhance_zhu:SelectConfigData,
				},
				config:{
                    update:(config,map) => void,
                    /** 游戏模式 */
                    identity_mode:SelectConfigData,
                    /** 游戏人数 */
                    player_number:SelectConfigData,
                    /** 双内奸 */
                    double_nei:SelectConfigData,
                    /** 神武将选择势力 */
                    choose_group:SelectConfigData,
                    /** 双将模式 */
                    double_character:SelectConfigData,
                    /** 特殊身份 */
                    special_identity:SelectConfigData,
                    /** 明忠卡牌替换 */
                    zhong_card:SelectConfigData,
                    /** 双将体力上限 */
                    double_hp:SelectConfigData,
                    /** 自动显示身份 */
                    auto_identity:SelectConfigData,
                    /** 自动标记身份 */
                    auto_mark_identity:SelectConfigData,
                    /** 加强主公 */
                    enhance_zhu:SelectConfigData,
                    /** 自由选将 */
                    free_choose:SelectConfigData,
                    /** 自由选择身份和座位 */
                    change_identity:SelectConfigData,
                    /** 开启换将卡 */
                    change_choice:SelectConfigData,
                    /** 开启手气卡 */
                    change_card:SelectConfigData,
                    /** 显示再战 */
                    continue_game:SelectConfigData,
                    /** 死亡后显示重来 */
                    dierestart:SelectConfigData,
                    /** 死亡后显示复活 */
                    revive:SelectConfigData,
                    /** 屏蔽身份 */
                    ban_identity:SelectConfigData,
                    /** 屏蔽身份2 */
                    ban_identity2:SelectConfigData,
                    /** 屏蔽身份3 */
                    ban_identity3:SelectConfigData,
                    /** 内奸策略 */
                    ai_strategy:SelectConfigData,
                    /** AI对人类态度 */
                    difficulty:SelectConfigData,
                    /** 主公候选武将数 */
                    choice_zhu:SelectConfigData,
                    /** 忠臣候选武将数 */
                    choice_zhong:SelectConfigData,
                    /** 内奸候选武将数 */
                    choice_nei:SelectConfigData,
                    /** 反贼候选武将数 */
					choice_fan:SelectConfigData,
				}
            },
            /** 国战 */
			guozhan:{
				name:string,
				connect:{
                    update:(config,map) => void,
                    /** 游戏人数 */
                    connect_player_number:SelectConfigData,
                    /** 首亮奖励 */
                    connect_initshow_draw:SelectConfigData,
                    /** 鏖战模式 */
                    connect_aozhan:SelectConfigData,
                    /** 观看下家副将 */
                    connect_viewnext:SelectConfigData,
                    /** 珠联璧合 */
                    connect_zhulian:SelectConfigData,
                    /** 使用国战牌堆 */
                    connect_guozhanpile:SelectConfigData,
                    /** 使用国战武将 */
                    connect_onlyguozhan:SelectConfigData,
                    /** 替换君主 */
					connect_junzhu:SelectConfigData,
				},
				config:{
                    update:(config,map) => void,
                    /** 游戏模式 */
                    guozhan_mode:SelectConfigData,
                    /** 游戏人数 */
                    player_number:SelectConfigData,
                    /** 首亮奖励 */
                    initshow_draw:SelectConfigData,
                    /** 鏖战模式 */
                    aozhan:SelectConfigData,
                    /** 观看下家副将 */
                    viewnext:SelectConfigData,
                    /** 鏖战背景音乐 */
                    aozhan_bgm:SelectConfigData,
                    /** 珠联璧合 */
                    zhulian:SelectConfigData,
                    /** 使用国战牌堆 */
                    guozhanpile:SelectConfigData,
                    /** 使用国战武将 */
                    onlyguozhan:SelectConfigData,
                    /** 使用国战皮肤 */
                    guozhanSkin:SelectConfigData,
                    /** 替换君主 */
                    junzhu:SelectConfigData,
                    /** 双将体力上限 */
                    double_hp:SelectConfigData,
                    /** 自由选将 */
                    free_choose:SelectConfigData,
                    /** 默认展开自由选将 */
                    onlyguozhanexpand:SelectConfigData,
                    /** 自由选择座位 */
                    change_identity:SelectConfigData,
                    /** 开启换将卡 */
                    change_choice:SelectConfigData,
                    /** 开启手气卡 */
                    change_card:SelectConfigData,
                    /** 显示再战 */
                    continue_game:SelectConfigData,
                    /** 死亡后显示重来 */
                    dierestart:SelectConfigData,
                    /** 死亡后显示复活 */
                    revive:SelectConfigData,
                    /** AI对人类态度 */
                    difficulty:SelectConfigData,
                    /** 候选武将数 */
					choice_num:SelectConfigData,
				}
            },
            /** 对决(分为两份对战) */
			versus:{
				name:'对决',
				connect:{
                    update:(config,map) => void,
                    /** 游戏模式 */
                    connect_versus_mode:SelectConfigData,
                    /** 末位可换牌 */
                    connect_replace_handcard:SelectConfigData,
                    /** 侯选武将数 */
                    connect_choice_num:SelectConfigData,
                    /** 替补人数 */
					connect_replace_number:SelectConfigData,
				},
				config:{
                    update:(config,map) => void,
                    /** 游戏模式 */
                    versus_mode:SelectConfigData,
                    /** 天梯模式 */
                    ladder:SelectConfigData,
                    /** 每月重置天梯 */
                    ladder_monthly:SelectConfigData,
                    /** 启用全部武将 */
                    enable_all:SelectConfigData,
                    /** 启用全部卡牌 */
                    enable_all_cards_four:SelectConfigData,
                    /** 启用全部武将 */
                    enable_all_three:SelectConfigData,
                    /** 启用全部卡牌 */
                    enable_all_cards:SelectConfigData,
                    /** 代替队友选将 */
                    four_assign:SelectConfigData,
                    /** 代替队友行动 */
                    four_phaseswap:SelectConfigData,
                    /** 代替队友选将 */
                    two_assign:SelectConfigData,
                    /** 代替队友行动 */
                    two_phaseswap:SelectConfigData,
                    /** 自由选将 */
                    free_choose:SelectConfigData,
                    /** 自由选择阵型 */
                    fouralign:SelectConfigData,
                    /** 自由选择座位 */
                    change_identity:SelectConfigData,
                    /** 开启换将卡 */
                    change_choice:SelectConfigData,
                    /** 双将模式 */
                    double_character_jiange:SelectConfigData,
                    /** 末位可换牌 */
                    replace_handcard_two:SelectConfigData,
                    /** 替补模式 */
                    replace_character_two:SelectConfigData,
                    /** 默认展开选将框 */
                    expand_dialog:SelectConfigData,
                    /** 专属武将出场率 */
                    siguo_character:SelectConfigData,
                    /** 重置天梯数据 */
					ladder_reset:SelectConfigData,
				}
            },
            /** 联机 */
			connect:{
				name:string,
				config:{
                    /** 联机昵称 */
                    connect_nickname:SelectConfigData,
                    /** 联机头像 */
                    connect_avatar:SelectConfigData,
                    /** 联机大厅 */
                    hall_ip:SelectConfigData,
                    /** 联机大厅按钮 */
                    hall_button:SelectConfigData,
                    /** 创建服务器按钮 */
					room_button:SelectConfigData
				}
            },
            /** 挑战 */
			boss:{
				name:'挑战',
				config:{
                    /** 自由选将 */
                    free_choose:SelectConfigData,
                    /** 开启换将卡 */
                    change_choice:SelectConfigData,
                    /** 单人控制 */
					single_control:SelectConfigData,
				}
            },
            /** 扩展玩法：斗地主 */
            doudizhu:CommonMenuConfigData,
            /** 扩展玩法：战棋 */
            chess:CommonMenuConfigData,
            /** 扩展玩法：塔防 */
            tafang:CommonMenuConfigData,
            /** 扩展玩法：乱斗 */
            brawl:CommonMenuConfigData,
            /** 扩展玩法：炉石 */
			stone:CommonMenuConfigData
		},
		status:{
			running:boolean,
			canvas:boolean,
			time:number,
			reload:number,
			delayed:number,
			frameId:number,
			videoId:number,
            globalId:number,
		},
		help:SMap<string>,
		setIntro:(node:HTMLDivElement,func,left) => void,
		setPopped:(node:HTMLDivElement,func,width,height,forceclick,paused2) => void,
		placePoppedDialog:(dialog,e) => void,
		setHover:(node:HTMLDivElement,func,hoveration,width) => HTMLDivElement,
		setScroll:(node:HTMLDivElement) => HTMLDivElement,
		setMousewheel:(node:HTMLDivElement) => void,
		setLongPress:(node:HTMLDivElement,func) => HTMLDivElement,
		updateCanvas:(time) => boolean,
		run:(time) => void,
		getUTC:(date) => number,
		saveVideo:() => void,
		init:{
			/** 游戏初始化 */
			init:() => void,
			reset:() => void,
			onload:() => void,
			startOnline:() => void,
			onfree:() => void,
			connection:(ws) => void,
			sheet:() => HTMLElement,
			css:(path,file,before) => HTMLElement,
			js:(path,file,onload,onerror) => HTMLElement,
			req:(str,onload,onerror,master) => void,
			json:(url,onload,onerror) => void,
			cssstyles:() => void,
			layout:(layout,nosave) => void,
			background:() => void,
			parsex:(func) => string,
			parse:(func) => string,
			eval:(func) => any,
			encode:(strUni) => string,
			decode:(str) => string,
			stringify:(obj) => string,
			stringifySkill:(obj) => string,
		},
		cheat:{
            /** 将游戏内部的对象暴露到全局中 */
			i:() => void,
			dy:() => void,
			x:() => void,
			cfg:() => void,
			o:() => void,
			pt:() => void,
			q:() => void,
			p:(name,i,skin) => void,
			e:() => void,
			c:() => void,
			id:() => void,
			b:() => void,
			uy:(me) => void,
			gs:(name,act) => void,
			gc:(name,act) => void,
			a:(bool) => void,
			as:() => void,
			uj:() => void,
			u:() => void,
			r:(bool) => void,
			h:(player) => void,
			g:() => void,
			ga:(type) => void,
			gg:() => void,
			gx:(name,target) => void,
			gn:(name) => any,
			ge:(target) => void,
			gj:() => void,
			gf:() => void,
			d:(num,target) => void,
			s:() => void,
			t:(num) => void,
			to:() => void,
			tm:() => void,
			k:(i) => void,
			z:(name) => void,
		},
		translate:SMap<string>,
		element:{
			content:{
				chooseToDuiben:() => any,
				chooseToPSS:() => any,
				cardsDiscard:() => void,
				chooseToEnable:() => any,
				chooseToDisable:() => any,
				swapEquip:() => void,
				disableEquip:() => void,
				enableEquip:() => void,
				disableJudge:() => void,
				/*----分界线----*/
				phasing:() => void,
				toggleSubPlayer:() => void,
				exitSubPlayer:() => void,
				callSubPlayer:() => void,
				reverseOrder:() => void,
				addJudgeCard:() => void,
				equipCard:() => void,
				gameDraw:() => void,
				phaseLoop:() => void,
				loadPackage:() => void,
				loadMode:() => void,
				forceOver:() => void,
				arrangeTrigger:() => void,
				createTrigger:() => void,
				playVideoContent:() => void,
				waitForPlayer:() => void,
				replaceHandcards:() => void,
				replaceHandcardsOL:() => void,
				phase:() => void,
				phaseJudge:() => void,
				phaseDraw:() => void,
				phaseUse:() => void,
				phaseDiscard:() => void,
				chooseToUse:() => void,
				chooseToRespond:() => void,
				chooseToDiscard:() => any,
				chooseToCompareMultiple:() => any,
				chooseToCompare:() => void,
				chooseSkill:() => any,
				discoverCard:() => void,
				chooseButton:() => void,
				chooseCardOL:() => void,
				chooseButtonOL:() => void,
				chooseCard:() => void,
				chooseTarget:() => void,
				chooseCardTarget:() => void,
				chooseControl:() => void,
				chooseBool:() => void,
				chooseDrawRecover:() => void,
				choosePlayerCard:() => void,
				discardPlayerCard:() => void,
				gainPlayerCard:() => void,
				showHandcards:() => void,
				showCards:() => void,
				viewCards:() => void,
				moveCard:() => void,
				useCard:() => void,
				useSkill:() => void,
				draw:() => void,
				discard:() => void,
				respond:() => void,
				swapHandcards:() => void,
				gainMultiple:() => void,
				gain:() => void,
				lose:() => void,
				damage:() => void,
				recover:() => void,
				loseHp:() => void,
				doubleDraw:() => void,
				loseMaxHp:() => void,
				gainMaxHp:() => void,
				changeHp:() => void,
				changeHujia:() => void,
				dying:() => void,
				die:() => void,
				equip:() => void,
				addJudge:() => void,
				judge:() => void,
				turnOver:() => void,
				link:() => void,
			},
			player:{
				//新函数
				chooseToDuiben:(target) => any,
				chooseToPSS:(target) => any,
				chooseToEnable:() => any,
	            chooseToDisable:(horse) => any,
	            countDisabled:() => number,
				isPhaseUsing:(notmeisok) => boolean,
				swapEquip:(target) => any,
				canCompare:(target) => boolean,
				disableEquip:(pos) => any,
				$disableEquip:(skill) => any,
				enableEquip:(pos) => any,
				$enableEquip:(skill) => any,
				isDisabled:(arg) => boolean,
				isEmpty:(num) => boolean,
				disableJudge:() => any,
				//原有函数
				init:(character,character2,skill) => void,
				initOL:(name,character) => void,
				uninitOL:() => void,
				initRoom:(info,info2) => any,
				reinit:(from,to,maxHp,online) => void,
				uninit:() => any,
				getLeft:() => any,
				getTop:() => any,
				smoothAvatar:(vice,video) => void,
				changeSeat:(position,video) => void,
				send:() => any,
				getId:() => any,
				chat:(str) => void,
				say:(str) => void,
				showGiveup:() => void,
				applySkills:(skills) => void,
				getState:() => any,
				setNickname:(str) => any,
				setAvatar:(name,name2,video,fakeme) => void,
				setAvatarQueue:(name, list) => void,
				flashAvatar:(skill,name) => void,
				update:() => void,
				updateMark:(i,storage) => any,
				updateMarks:(connect) => void,
				num:(arg1,arg2,arg3) => void,
				line:(target,config) => void,
				line2:(targets,config) => void,
				getNext:() => any,
				getPrevious:() => any,
				countUsed:(card) => number,
				countSkill:(skill) => number,
				getStockSkills:(unowned,unique,hidden) => any,
				getCards:(arg1,arg2) => any[],
				getDiscardableCards:(player,arg1,arg2) => any[],
				getGainableCards:(player,arg1,arg2) => any[],
				getGainableSkills:(func) => any[],
				countCards:(arg1,arg2) => number,
				countDiscardableCards:(player,arg1,arg2) => number,
				countGainableCards:(player,arg1,arg2) => number,
				getOriginalSkills:() => any[],
				getSkills:(arg2,arg3,arg4) => any[],
				get:(arg1,arg2,arg3,arg4) => any[],
				syncStorage:(skill) => void,
				syncSkills:() => void,
				playerfocus:(time) => any,
				setIdentity:(identity) => any,
				insertPhase:(skill,insert) => any,
				insertEvent:(name,content,arg) => any,
				phase:(skill) => any,
				phaseJudge:() => any,
				phaseDraw:() => any,
				phaseUse:() => any,
				phaseDiscard:() => any,
				chooseToUse:(use) => any,
				chooseToRespond:() => any,
				chooseToDiscard:() => any,
				chooseToCompare:(target,check) => any,
				chooseSkill:(target) => void,
				discoverCard:(list) => any,
				chooseCardButton:() => any,
				chooseVCardButton:() => any,
				chooseButton:() => any,
				chooseButtonOL:(list,callback,ai) => any,
				chooseCardOL:() => any,
				chooseCard:() => any,
				chooseUseTarget:(card,prompt,includecard) => any,
				chooseTarget:() => any,
				chooseCardTarget:(choose) => any,
				chooseControlList:() => any,
				chooseControl:() => any,
				chooseBool:() => any,
				chooseDrawRecover:() => any,
				choosePlayerCard:() => any,
				discardPlayerCard:() => any,
				gainPlayerCard:() => any,
				showHandcards:(str) => any,
				showCards:(cards,str) => any,
				viewCards:(str,cards) => any,
				viewHandcards:(target) => any,
				canMoveCard:(withatt) => any,
				moveCard:() => any,
				useResult:(result,event) => any,
				useCard:() => any,
				useSkill:() => any,
				draw:() => any,
				randomDiscard:() => any[],
				randomGain:() => any[],
				discard:() => any,
				respond:() => any,
				swapHandcards:(target,cards1,cards2) => any,
				directequip:(cards) => void,
				directgain:(cards) => any,
				gainMultiple:(targets,position) => any,
				gain:() => any,
				give:(cards,target,visible) => void,
				lose:() => any,
				damage:() => any,
				recover:() => any,
				doubleDraw:() => any,
				loseHp:(num) => any,
				loseMaxHp:() => any,
				gainMaxHp:function(){
					var next=game.createEvent('gainMaxHp');
					next.player=this;
					next.num=1;
					for(var i=0;i<arguments.length;i++){
						if(typeof arguments[i]==='number'){
							next.num=arguments[i];
						}
						else if(typeof arguments[i]==='boolean'){
							next.forced=arguments[i];
						}
					}
					next.setContent('gainMaxHp');
					return next;
				},
				changeHp:function(num,popup){
					var next=game.createEvent('changeHp',false);
					next.num=num;
					if(popup!=undefined) next.popup=popup;
					next.player=this;
					next.setContent('changeHp');
					return next;
				},
	
				changeHujia:function(num,type){
					var next=game.createEvent('changeHujia');
					if(typeof num!='number'){
						num=1;
					}
					next.num=num;
					next.player=this;
					if(type) next.type=type;
					next.setContent('changeHujia');
					return next;
				},
				getBuff:function(){
					var list=[1,2,3,4,5,6];
					var nodelay=false;
					for(var i=0;i<arguments.length;i++){
						if(typeof arguments[i]=='number'){
							list.remove(arguments[i]);
						}
						else if(arguments[i]===false){
							nodelay=true;
						}
					}
					if(this.isHealthy()){
						list.remove(2);
					}
					if(!this.countCards('j')){
						list.remove(5);
					}
					if(!this.isLinked()&&!this.isTurnedOver()){
						list.remove(6);
					}
					if(this.hasSkill('qianxing')){
						list.remove(4);
					}
					switch(list.randomGet()){
						case 1:this.draw(nodelay?'nodelay':1);break;
						case 2:this.recover();break;
						case 3:this.changeHujia();break;
						case 4:this.tempHide();
						case 5:this.discard(this.getCards('j')).delay=(!nodelay);break;
						case 6:{
							if(this.isLinked()) this.link();
							if(this.isTurnedOver()) this.turnOver();
							break;
						}
					}
					return this;
				},
				getDebuff:function(){
					var list=[1,2,3,4,5,6];
					var nodelay=false;
					for(var i=0;i<arguments.length;i++){
						if(typeof arguments[i]=='number'){
							list.remove(arguments[i]);
						}
						else if(arguments[i]===false){
							nodelay=true;
						}
					}
					if(this.countCards('he')==0){
						list.remove(1);
					}
					if(this.isLinked()){
						list.remove(4);
					}
					if(this.hasSkill('fengyin')){
						list.remove(5);
					}
					if(this.hp==1){
						list.remove(3);
						if(list.length>1) list.remove(2);
					}
					if(!list.length) return this;
					var num=list.randomGet();
					switch(list.randomGet()){
						case 1:this.randomDiscard(nodelay?false:'he');break;
						case 2:this.loseHp();break;
						case 3:this.damage();break;
						case 4:if(!this.isLinked()) this.link();break;
						case 5:this.addTempSkill('fengyin',{player:'phaseAfter'});break;
						case 6:{
							var list=[];
							for(var i=0;i<lib.inpile.length;i++){
								var info=lib.card[lib.inpile[i]];
								if(info.type=='delay'&&!info.cancel&&!this.hasJudge(lib.inpile[i])){
									list.push(lib.inpile[i]);
								}
							}
							if(list.length){
								var card=game.createCard(list.randomGet());
								this.addJudge(card);
								this.$draw(card);
								if(!nodelay) game.delay();
							}
							else{
								this.getDebuff(6);
							}
							break;
						}
					}
					return this;
				},
				dying:function(reason){
					if(this.nodying||this.hp>0||this.isDying()) return;
					var next=game.createEvent('dying');
					next.player=this;
					next.reason=reason;
					next.source=reason.source;
					next.setContent('dying');
					return next;
				},
				die:function(reason){
					var next=game.createEvent('die');
					next.player=this;
					next.reason=reason;
					if(reason) next.source=reason.source;
					next.setContent('die');
					return next;
				},
				revive:function(hp,log){
					if(log!==false) game.log(this,'复活');
					if(this.maxHp<1) this.maxHp=1;
					if(hp) this.hp=hp;
					else{
						this.hp=1;
					}
					game.addVideo('revive',this);
					this.classList.remove('dead');
					this.removeAttribute('style');
					this.node.avatar.style.transform='';
					this.node.avatar2.style.transform='';
					this.node.hp.show();
					this.node.equips.show();
					this.node.count.show();
					this.update();
					var player;
					player=this.previousSeat;
					while(player.isDead()) player=player.previousSeat;
					player.next=this;
					this.previous=player;
					player=this.nextSeat;
					while(player.isDead()) player=player.nextSeat;
					player.previous=this;
					this.next=player;
					game.players.add(this);
					game.dead.remove(this);
					if(this==game.me){
						if(ui.auto) ui.auto.show();
						if(ui.wuxie) ui.wuxie.show();
						if(ui.revive){
							ui.revive.close();
							delete ui.revive;
						}
						if(ui.exit){
							ui.exit.close();
							delete ui.exit;
						}
						if(ui.swap){
							ui.swap.close();
							delete ui.swap;
						}
						if(ui.restart){
							ui.restart.close();
							delete ui.restart;
						}
						if(ui.continue_game){
							ui.continue_game.close();
							delete ui.continue_game;
						}
					}
				},
				isMad:function(){
					return this.hasSkill('mad');
				},
				goMad:function(end){
					if(end){
						this.addTempSkill('mad',end);
					}
					else{
						this.addSkill('mad');
					}
					game.log(this,'进入混乱状态');
				},
				unMad:function(){
					this.removeSkill('mad');
				},
				tempHide:function(){
					this.addTempSkill('qianxing',{player:'phaseBegin'});
				},
				addExpose:function(num){
					if(typeof this.ai.shown=='number'&&!this.identityShown&&this.ai.shown<1){
						this.ai.shown+=num;
						if(this.ai.shown>0.95){
							this.ai.shown=0.95;
						}
					}
					return this;
				},
				equip:function(card,draw){
					var next=game.createEvent('equip');
					next.card=card;
					next.player=this;
					if(draw){
						next.draw=true;
					}
					next.setContent(lib.element.content.equip);
					return next;
				},
				addJudge:function(card,cards){
					var next=game.createEvent('addJudge');
					next.card=card;
					next.cards=cards;
					if(next.cards==undefined) next.cards=[card];
					if(get.itemtype(next.cards)=='card') next.cards=[next.cards];
					next.player=this;
					next.setContent('addJudge');
					return next;
				},
				canAddJudge:function(card){
					var name;
					if(typeof card=='string'){
						name=card;
					}
					else{
						name=card.viewAs||card.name;
					}
					if(!name) return false;
					if(this.hasJudge(name)) return false;
					var mod=game.checkMod(card,this,this,'unchanged','targetEnabled',this);
					if(mod!='unchanged') return mod;
					return true;
				},
				addJudgeNext:function(card){
					if(!card.expired){
						var target=this.next;
						var name=card.viewAs||card.name;
						for(var iwhile=0;iwhile<20;iwhile++){
							if(target==this||target.canAddJudge(card)){
								break;
							}
							target=target.next;
						}
						if(target==this){
							game.cardsDiscard(card);
						}
						else{
							if(card.name!=name){
								target.addJudge(name,card);
							}
							else{
								target.addJudge(card);
							}
						}
					}
					else{
						card.expired=false;
					}
				},
				judge:function(){
					var next=game.createEvent('judge');
					next.player=this;
					for(var i=0;i<arguments.length;i++){
						if(get.itemtype(arguments[i])=='card'){
							next.card=arguments[i];
						}
						else if(typeof arguments[i]=='string'){
							next.skill=arguments[i];
						}
						else if(typeof arguments[i]=='function'){
							next.judge=arguments[i];
						}
						else if(typeof arguments[i]=='boolean'){
							next.clearArena=arguments[i];
						}
						else if(get.objtype(arguments[i])=='div'){
							next.position=arguments[i];
						}
					}
					if(next.card&&next.judge==undefined){
						next.judge=get.judge(next.card);
					}
					if(next.judge==undefined) next.judge=function(){return 0};
					if(next.position==undefined) next.position=ui.discardPile;
	
					var str='';
					if(next.card) str=get.translation(next.card.viewAs||next.card.name);
					else if(next.skill) str=get.translation(next.skill);
					else str=get.translation(_status.event.name);
					next.judgestr=str;
					next.setContent('judge');
					return next;
				},
				turnOver:function(bool){
					if(typeof bool=='boolean'){
						if(bool){
							if(this.isTurnedOver()) return;
						}
						else{
							if(!this.isTurnedOver()) return;
						}
					}
					var next=game.createEvent('turnOver');
					next.player=this;
					next.setContent('turnOver');
					return next;
				},
				out:function(skill){
					if(typeof skill=='number'){
						this.outCount+=skill;
					}
					else if(typeof skill=='string'){
						if(!this.outSkills){
							this.outSkills=[];
						}
						this.outSkills.add(skill);
					}
					else{
						this.outCount++;
					}
					if(!this.classList.contains('out')){
						this.classList.add('out');
						game.log(this,'离开游戏');
					}
					if(!game.countPlayer()){
						game.over();
					}
				},
				in:function(skill){
					if(this.isOut()){
						if(typeof skill=='string'){
							if(this.outSkills){
								this.outSkills.remove(skill);
								if(!this.outSkills.length){
									delete this.outSkills;
								}
							}
						}
						else if(typeof skill=='number'){
							this.outCount-=skill;
						}
						else{
							if(skill===true){
								delete this.outSkills;
							}
							this.outCount=0;
						}
						if(this.outCount<=0&&!this.outSkills){
							this.outCount=0;
							this.classList.remove('out');
							game.log(this,'进入游戏');
						}
					}
				},
				link:function(bool){
					if(typeof bool=='boolean'){
						if(bool){
							if(this.isLinked()) return;
						}
						else{
							if(!this.isLinked()) return;
						}
					}
					var next=game.createEvent('link');
					next.player=this;
					next.setContent('link');
					return next;
				},
				skip:function(name){
					this.skipList.add(name);
				},
				wait:function(callback){
					if(lib.node){
						if(typeof callback=='function'){
							callback._noname_waiting=true;
							lib.node.torespond[this.playerid]=callback;
						}
						else{
							lib.node.torespond[this.playerid]='_noname_waiting';
						}
						clearTimeout(lib.node.torespondtimeout[this.playerid]);
						if(this.ws&&!this.ws.closed){
							var player=this;
							var time=parseInt(lib.configOL.choose_timeout)*1000;
							if(_status.event.getParent().skillHidden){
								for(var i=0;i<game.players.length;i++){
									game.players[i].showTimer(time);
								}
								player._hide_all_timer=true;
							}
							else if(!_status.event._global_waiting){
								player.showTimer(time);
							}
							lib.node.torespondtimeout[this.playerid]=setTimeout(function(){
								player.unwait('ai');
								player.ws.ws.close();
							},time+5000);
						}
					}
				},
				unwait:function(result){
					if(this._hide_all_timer){
						delete this._hide_all_timer;
						for(var i=0;i<game.players.length;i++){
							game.players[i].hideTimer();
						}
					}
					else if(!_status.event._global_waiting){
						this.hideTimer();
					}
					clearTimeout(lib.node.torespondtimeout[this.playerid]);
					delete lib.node.torespondtimeout[this.playerid];
					if(!lib.node.torespond.hasOwnProperty(this.playerid)){
						return;
					}
					var noresume=false;
					var proceed=null;
					if(typeof lib.node.torespond[this.playerid]=='function'&&lib.node.torespond[this.playerid]._noname_waiting){
						proceed=lib.node.torespond[this.playerid](result,this);
						if(proceed===false){
							noresume=true;
						}
					}
					lib.node.torespond[this.playerid]=result;
					for(var i in lib.node.torespond){
						if(lib.node.torespond[i]=='_noname_waiting'){
							return;
						}
						else if(lib.node.torespond[i]&&lib.node.torespond[i]._noname_waiting){
							return;
						}
					}
					_status.event.result=result;
					_status.event.resultOL=lib.node.torespond;
					lib.node.torespond={};
					if(typeof proceed=='function') proceed();
					else if(_status.paused&&!noresume) game.resume();
				},
				logSkill:function(name,targets,nature,logv){
					if(get.itemtype(targets)=='player') targets=[targets];
					var nopop=false;
					if(Array.isArray(name)){
						this.popup(name[1]);
						name=name[0];
						nopop=true;
					}
					var checkShow=this.checkShow(name);
					if(lib.translate[name]){
						if(lib.config.skill_animation_type!='off'&&lib.skill[name]&&lib.skill[name].skillAnimation){
							if(lib.config.skill_animation_type=='default'){
								checkShow=checkShow||'main';
							}
							else{
								checkShow=false;
							}
							if(lib.skill[name].textAnimation){
								checkShow=false;
							}
							this.$skill(lib.skill[name].animationStr||lib.translate[name],lib.skill[name].skillAnimation,lib.skill[name].animationColor,checkShow);
						}
						else if(!nopop) this.popup(get.skillTranslation(name,this));
						if(typeof targets=='object'&&targets.length){
							var str='对<span class="bluetext">'+(targets[0]==this?'自己':get.translation(targets[0]));
							for(var i=1;i<targets.length;i++){
								str+='、'+(targets[i]==this?'自己':get.translation(targets[i]));
							}
							str+='</span>发动了';
							game.log(this,str,'【'+get.skillTranslation(name,this)+'】');
						}
						else{
							game.log(this,'发动了','【'+get.skillTranslation(name,this)+'】');
						}
					}
					if(nature!=false){
						if(nature===undefined){
							nature='green';
						}
						this.line(targets,nature);
					}
					var info=lib.skill[name];
					if(info&&info.ai&&info.ai.expose!=undefined&&
						this.logAi&&(!targets||targets.length!=1||targets[0]!=this)){
						this.logAi(lib.skill[name].ai.expose);
					}
					if(info&&info.round){
						var roundname=name+'_roundcount';
						this.storage[roundname]=game.roundNumber;
						this.syncStorage(roundname);
						this.markSkill(roundname);
					}
					game.trySkillAudio(name,this,true);
					if(game.chess){
						this.chessFocus();
					}
					if(logv===true){
						game.logv(this,name,targets,null,true);
					}
					else if(info&&info.logv!==false){
						game.logv(this,name,targets);
					}
					if(this._hookTrigger){
						for(var i=0;i<this._hookTrigger.length;i++){
							var info=lib.skill[this._hookTrigger[i]].hookTrigger;
							if(info&&info.log){
								info.log(this,name,targets);
							}
						}
					}
				},
				unprompt:function(){
					if(this.node.prompt){
						this.node.prompt.delete();
						delete this.node.prompt;
					}
				},
				prompt:function(str,nature){
					var node;
					if(this.node.prompt){
						node=this.node.prompt;
						node.innerHTML='';
						node.className='damage normal-font damageadded';
					}
					else{
						node=ui.create.div('.damage.normal-font',this);
						this.node.prompt=node;
						ui.refresh(node);
						node.classList.add('damageadded');
					}
					node.innerHTML=str;
					node.dataset.nature=nature||'soil';
				},
				prompt_old:function(name2,className){
					var node;
					if(this.node.prompt){
						node=this.node.prompt;
						node.innerHTML='';
						node.className='popup';
					}
					else{
						node=ui.create.div('.popup',this.parentNode);
						this.node.prompt=node;
					}
					node.dataset.position=this.dataset.position;
					if(this.dataset.position==0||parseInt(this.dataset.position)==parseInt(ui.arena.dataset.number)/2||
						typeof name2=='number'||this.classList.contains('minskin')){
						node.innerHTML=name2;
					}
					else{
						for(var i=0;i<name2.length;i++){
							node.innerHTML+=name2[i]+'<br/>';
						}
					}
					if(className){
						node.classList.add(className);
					}
				},
				popup:function(name,className){
					var name2=get.translation(name);
					if(!name2) return;
					this.$damagepop(name2,className||'water',true);
				},
				popup_old:function(name,className){
					var name2=get.translation(name);
					var node=ui.create.div('.popup',this.parentNode);
					if(!name2){
						node.remove();
						return node;
					}
					game.addVideo('popup',this,[name,className]);
					node.dataset.position=this.dataset.position;
					if(this.dataset.position==0||parseInt(this.dataset.position)==parseInt(ui.arena.dataset.number)/2||
						typeof name2=='number'||this.classList.contains('minskin')){
						node.innerHTML=name2;
					}
					else{
						for(var i=0;i<name2.length;i++){
							node.innerHTML+=name2[i]+'<br/>';
						}
					}
					if(className){
						node.classList.add(className);
					}
					this.popups.push(node);
					if(this.popups.length>1){
						node.hide();
					}
					else{
						var that=this;
						setTimeout(function(){that._popup();},1000);
					}
					return node;
				},
				_popup:function(){
					if(this.popups.length){
						this.popups.shift().delete();
						if(this.popups.length){
							this.popups[0].show();
							var that=this;
							setTimeout(function(){that._popup();},1000);
						}
					}
				},
				showTimer:function(time){
					if(!time&&lib.configOL){
						time=parseInt(lib.configOL.choose_timeout)*1000;
					}
					if(_status.connectMode&&!game.online){
						game.broadcast(function(player,time){
							player.showTimer(time);
						},this,time);
					}
					if(this==game.me){
						return;
					}
					if(this.node.timer){
						this.node.timer.remove();
					}
					var timer=ui.create.div('.timerbar',this);
					this.node.timer=timer;
					ui.create.div(this.node.timer);
					var bar=ui.create.div(this.node.timer);
					ui.refresh(bar);
					bar.style.transitionDuration=(time/1000)+'s';
					bar.style.width=0;
				},
				hideTimer:function(){
					if(_status.connectMode&&!game.online&&this.playerid){
						game.broadcast(function(player){
							player.hideTimer();
						},this);
					}
					if(this.node.timer){
						this.node.timer.delete();
						delete this.node.timer;
					}
				},
				markSkill:function(name,info,card){
					if(info===true){
						this.syncStorage(name);
						info=null;
					}
					if(get.itemtype(card)=='card'){
						game.addVideo('markSkill',this,[name,get.cardInfo(card)]);
					}
					else{
						game.addVideo('markSkill',this,[name]);
					}
					game.broadcastAll(function(storage,player,name,info,card){
						if(storage!=undefined){
							player.storage[name]=storage;
						}
						if(!info){
							if(player.marks[name]){
								player.updateMarks();
								return;
							}
							if(lib.skill[name]){
								info=lib.skill[name].intro;
							}
							if(!info){
								return;
							}
						}
						if(player.marks[name]){
							player.marks[name].info=info;
						}
						else{
							if(card){
								player.marks[name]=player.mark(card,info,name);
							}
							else{
								player.marks[name]=player.mark(name,info);
							}
						}
						player.updateMarks();
					},this.storage[name],this,name,info,card);
					return this;
				},
				unmarkSkill:function(name){
					game.addVideo('unmarkSkill',this,name);
					game.broadcast(function(player,name){
						if(player.marks[name]){
							player.marks[name].delete();
							player.marks[name].style.transform+=' scale(0.2)';
							delete player.marks[name];
							ui.updatem(player);
						}
					},this,name);
					if(this.marks[name]){
						this.marks[name].delete();
						this.marks[name].style.transform+=' scale(0.2)';
						delete this.marks[name];
						ui.updatem(this);
						var info=lib.skill[name];
						if(info&&info.intro&&info.intro.onunmark){
							if(info.intro.onunmark=='throw'){
								if(get.itemtype(this.storage[name])=='cards'){
									this.$throw(this.storage[name]);
									game.cardsDiscard(this.storage[name]);
								}
							}
							else if(typeof info.intro.onunmark=='function'){
								info.intro.onunmark(this.storage[name],this);
							}
						}
					}
					return this;
				},
				markSkillCharacter:function(id,target,name,content){
					if(typeof target=='object'){
						target=target.name;
					}
					game.broadcastAll(function(player,target,name,content,id){
						if(player.marks[id]){
							player.marks[id].name=name+'_charactermark';
							player.marks[id]._name=target;
							player.marks[id].info={
								name:name,
								content:content,
								id:id
							};
							player.marks[id].setBackground(target,'character');
							game.addVideo('changeMarkCharacter',player,{
								id:id,
								name:name,
								content:content,
								target:target
							});
						}
						else{
							player.marks[id]=player.markCharacter(target,{
								name:name,
								content:content,
								id:id
							});
							player.marks[id]._name=target;
							game.addVideo('markCharacter',player,{
								name:name,
								content:content,
								id:id,
								target:target
							});
						}
					},this,target,name,content,id);
					return this;
				},
				markCharacter:function(name,info,learn,learn2){
					if(typeof name=='object'){
						name=name.name;
					}
					var node;
					if(name.indexOf('unknown')==0){
						node=ui.create.div('.card.mark.drawinghidden');
						ui.create.div('.background.skillmark',node).innerHTML=get.translation(name)[0];
					}
					else{
						if(!lib.character[name]) return;
						node=ui.create.div('.card.mark.drawinghidden').setBackground(name,'character');
					}
					this.node.marks.insertBefore(node,this.node.marks.childNodes[1]);
					node.name=name+'_charactermark';
					if(!info){
						info={};
					}
					if(!info.name){
						info.name=get.translation(name);
					}
					if(!info.content){
						info.content=get.skillintro(name,learn,learn2)
					}
					node.info=info;
					node.addEventListener(lib.config.touchscreen?'touchend':'click',ui.click.card);
					if(!lib.config.touchscreen){
						if(lib.config.hover_all){
							lib.setHover(node,ui.click.hoverplayer);
						}
						if(lib.config.right_info){
							node.oncontextmenu=ui.click.rightplayer;
						}
					}
					ui.updatem(this);
					return node;
				},
				mark:function(name,info,skill){
					if(get.itemtype(name)=='cards'){
						var marks=[];
						for(var i=0;i<name.length;i++){
							marks.push(this.mark(name[i],info));
						}
						return marks;
					}
					else{
						var node;
						if(get.itemtype(name)=='card'){
							node=name.copy('mark');
							node.classList.add('drawinghidden');
							this.node.marks.insertBefore(node,this.node.marks.childNodes[1]);
							node.suit=name.suit;
							node.number=name.number;
							// if(name.name&&lib.card[name.name]&&lib.card[name.name].markimage){
							// 	node.node.image.style.left=lib.card[name.name].markimage;
							// }
	
							if(name.classList.contains('fullborder')){
								node.classList.add('fakejudge');
								node.classList.add('fakemark');
								(node.querySelector('.background')||ui.create.div('.background',node)).innerHTML=lib.translate[name.name+'_bg']||get.translation(name.name)[0];
							}
	
							name=name.name;
						}
						else{
							node=ui.create.div('.card.mark.drawinghidden');
							this.node.marks.insertBefore(node,this.node.marks.childNodes[1]);
							var str=lib.translate[name+'_bg'];
							if(!str||str[0]=='+'||str[0]=='-'){
								str=get.translation(name)[0];
							}
							ui.create.div('.background.skillmark',node).innerHTML=str;
							// node.style.fontFamily=lib.config.card_font;
						}
						node.name=name;
						node.skill=skill||name;
						if(typeof info=='object'){
							node.info=info;
						}
						else if(typeof info=='string'){
							node.markidentifer=info;
						}
						node.addEventListener(lib.config.touchscreen?'touchend':'click',ui.click.card);
						if(!lib.config.touchscreen){
							if(lib.config.hover_all){
								lib.setHover(node,ui.click.hoverplayer);
							}
							if(lib.config.right_info){
								node.oncontextmenu=ui.click.rightplayer;
							}
						}
						this.updateMarks();
						ui.updatem(this);
						return node;
					}
				},
				unmark:function(name,info){
					game.addVideo('unmarkname',this,name);
					if(get.itemtype(name)=='card'){
						this.unmark(name.name,info);
					}
					else if(get.itemtype(name)=='cards'){
						for(var i=0;i<name.length;i++){
							this.unmark(name[i].name,info);
						}
					}
					else{
						for(var i=0;i<this.node.marks.childNodes.length;i++){
							if(this.node.marks.childNodes[i].name==name&&
								(!info||this.node.marks.childNodes[i].markidentifer==info)){
								this.node.marks.childNodes[i].delete();
								this.node.marks.childNodes[i].style.transform+=' scale(0.2)';
								ui.updatem(this);
								return;
							}
						}
					}
				},
				addLink:function(){
					if(get.is.linked2(this)){
						this.classList.add('linked2');
					}
					else{
						this.classList.add('linked');
					}
				},
				removeLink:function(){
					if(get.is.linked2(this)){
						this.classList.remove('linked2');
					}
					else{
						this.classList.remove('linked');
					}
				},
				canUse:function(card,target,distance,includecard){
					if(typeof card=='string') card={name:card};
					var info=get.info(card);
					if(info.multicheck&&!info.multicheck(card,this)) return false;
					if(includecard!=false&&!lib.filter.cardEnabled(card,this)) return false;
					if(includecard&&!lib.filter.cardUsable(card,this)) return false;
					if(distance==false) return lib.filter.targetEnabled(card,this,target);
					return lib.filter.filterTarget(card,this,target);
				},
				hasUseTarget:function(card,distance,includecard){
					var player=this;
					return game.hasPlayer(function(current){
						return player.canUse(card,current,distance,includecard);
					});
				},
				getUseValue:function(card,distance,includecard){
					if(typeof(card)=='string'){
						card={name:card};
					}
					var player=this;
					var targets=game.filterPlayer();
					var min=0;
					for(var i=0;i<targets.length;i++){
						if(player.canUse(card,targets[i],distance,includecard)){
							var eff=get.effect(targets[i],card,player,player);
							if(eff>min){
								min=eff;
							}
						}
					}
					return min;
				},
				addSubPlayer:function(cfg){
					var skill='subplayer_'+cfg.name+'_'+get.id();
					game.log(this,'获得了随从','#g'+get.translation(cfg.name))
					cfg.hs=cfg.hs||[];
					cfg.es=cfg.es||[];
					cfg.skills=cfg.skills||[];
					cfg.hp=cfg.hp||1;
					cfg.maxHp=cfg.maxHp||1;
					cfg.sex=cfg.sex||'male';
					cfg.group=cfg.group||'qun';
					cfg.skill=cfg.skill||_status.event.name;
					if(!cfg.source){
						if(this.hasSkill(_status.event.name)&&this.name2&&lib.character[this.name2]&&
							lib.character[this.name2][3].contains(_status.event.name)){
							cfg.source=this.name2;
						}
						else{
							cfg.source=this.name;
						}
					}
					game.broadcastAll(function(player,skill,cfg){
						lib.skill[skill]={
							intro:{
								content:cfg.intro||''
							}
							mark:'character',
							subplayer:cfg.skill,
							ai:{
								subplayer:true
							}
						}
						lib.character[skill]=[cfg.sex,cfg.group,cfg.maxHp,cfg.skills,['character:'+cfg.name]];
						lib.translate[skill]=cfg.caption||get.rawName(cfg.name);
						player.storage[skill]=cfg;
					},this,skill,cfg);
					game.addVideo('addSubPlayer',this,[skill,lib.skill[skill],lib.character[skill],lib.translate[skill],{name:cfg.name}]);
					this.addSkill(skill);
					return skill;
				},
				removeSubPlayer:function(name){
					if(this.hasSkill('subplayer')&&this.name==name){
						this.exitSubPlayer(true);
					}
					else{
						if(player.storage[name].onremove){
							player.storage[name].onremove(player);
						}
						this.removeSkill(name);
						delete this.storage[name];
						game.log(player,'牺牲了随从','#g'+name);
						_status.event.trigger('removeSubPlayer');
					}
				},
				callSubPlayer:function(){
					if(this.hasSkill('subplayer')) return;
					var next=game.createEvent('callSubPlayer');
					next.player=this;
					for(var i=0;i<arguments.length;i++){
						if(typeof arguments[i]=='string'){
							next.directresult=arguments[i];
						}
					}
					next.setContent('callSubPlayer');
					return next;
				},
				toggleSubPlayer:function(){
					if(!this.hasSkill('subplayer')) return;
					var next=game.createEvent('toggleSubPlayer');
					next.player=this;
					for(var i=0;i<arguments.length;i++){
						if(typeof arguments[i]=='string'){
							next.directresult=arguments[i];
						}
					}
					next.setContent('toggleSubPlayer');
					return next;
				},
				exitSubPlayer:function(remove){
					if(!this.hasSkill('subplayer')) return;
					var next=game.createEvent('exitSubPlayer');
					next.player=this;
					next.remove=remove;
					next.setContent('exitSubPlayer');
					return next;
				},
				getSubPlayers:function(tag){
					var skills=this.getSkills();
					var list=[];
					for(var i=0;i<skills.length;i++){
						var name=skills[i];
						var info=lib.skill[name];
						if(tag&&info.subplayer!=tag) continue;
						if(info.ai&&info.ai.subplayer&&this.storage[name]&&this.storage[name].name){
							list.push(name);
						}
					}
					return list;
				},
				addSkillTrigger:function(skill,hidden,triggeronly){
					var info=lib.skill[skill];
					if(!info) return;
					if(typeof info.group=='string'){
						this.addSkillTrigger(info.group,hidden);
					}
					else if(Array.isArray(info.group)){
						for(var i=0;i<info.group.length;i++){
							this.addSkillTrigger(info.group[i],hidden);
						}
					}
					if(!triggeronly){
						if(info.global&&(!hidden||info.globalSilent)){
							if(typeof info.global=='string'){
								game.addGlobalSkill(info.global,this);
							}
							else{
								for(var j=0;j<info.global.length;j++){
									game.addGlobalSkill(info.global[j],this);
								}
							}
						}
						if(this.initedSkills.contains(skill)) return this;
						this.initedSkills.push(skill);
						if(info.init&&!_status.video){
							info.init(this,skill);
						}
					}
					if(info.trigger&&this.playerid){
						var playerid=this.playerid;
						var setTrigger=function(i,evt){
							if(i=='global'){
								if(!lib.hook.globaltrigger[evt]){
									lib.hook.globaltrigger[evt]={};
								}
								if(!lib.hook.globaltrigger[evt][playerid]){
									lib.hook.globaltrigger[evt][playerid]=[];
								}
								lib.hook.globaltrigger[evt][playerid].add(skill);
							}
							else{
								var name=playerid+'_'+i+'_'+evt;
								if(!lib.hook[name]){
									lib.hook[name]=[];
								}
								lib.hook[name].add(skill);
							}
							lib.hookmap[evt]=true;
						}
						for(var i in info.trigger){
							if(typeof info.trigger[i]=='string'){
								setTrigger(i,info.trigger[i]);
							}
							else if(Array.isArray(info.trigger[i])){
								for(var j=0;j<info.trigger[i].length;j++){
									setTrigger(i,info.trigger[i][j]);
								}
							}
						}
					}
					if(info.hookTrigger){
						if(!this._hookTrigger){
							this._hookTrigger=[];
						}
						this._hookTrigger.add(skill);
					}
					if(_status.event&&_status.event.addTrigger) _status.event.addTrigger(skill,this);
					return this;
				},
				addSkillLog:function(skill){
					this.addSkill(skill);
					this.popup(skill);
					game.log(this,'获得了技能','【'+get.translation(skill)+'】');
				},
				addSkill:function(skill,checkConflict,nobroadcast){
					if(Array.isArray(skill)){
						for(var i=0;i<skill.length;i++){
							this.addSkill(skill[i]);
						}
					}
					else{
						if(this.skills.contains(skill)) return;
						var info=lib.skill[skill];
						if(!info) return;
						if(!nobroadcast){
							game.broadcast(function(player,skill){
								player.skills.add(skill);
							},this,skill);
						}
						this.skills.add(skill);
						this.addSkillTrigger(skill);
						if(this.awakenedSkills.contains(skill)){
							this.awakenSkill(skill);
							return;
						}
						if(info.init2&&!_status.video){
							info.init2(this,skill);
						}
						if(info.mark){
							if(info.mark=='card'&&
								get.itemtype(this.storage[skill])=='card'){
									this.markSkill(skill,null,this.storage[skill]);
							}
							else if(info.mark=='card'&&
								get.itemtype(this.storage[skill])=='cards'){
									this.markSkill(skill,null,this.storage[skill][0]);
							}
							else if(info.mark=='image'){
									this.markSkill(skill,null,ui.create.card(null,'noclick').init([null,null,skill]));
							}
							else if(info.mark=='character'){
								var intro=info.intro.content;
								if(typeof intro=='function'){
									intro=intro(this.storage[skill],this);
								}
								else if(typeof intro=='string'){
									intro=intro.replace(/#/g,this.storage[skill]);
									intro=intro.replace(/&/g,get.cnNumber(this.storage[skill]));
									intro=intro.replace(/\$/g,get.translation(this.storage[skill]));
								}
								var caption;
								if(typeof info.intro.name=='function'){
									caption=info.intro.name(this.storage[skill],this);
								}
								else if(typeof info.intro.name=='string'){
									caption=info.name;
								}
								else{
									caption=get.translation(skill);
								}
								this.markSkillCharacter(skill,this.storage[skill],caption,intro);
							}
							else{
								this.markSkill(skill);
							}
						}
					}
					if(checkConflict) this.checkConflict();
					return skill;
				},
				addAdditionalSkill:function(skill,skills,keep){
					if(this.additionalSkills[skill]){
						if(keep){
							if(typeof this.additionalSkills[skill]=='string'){
								this.additionalSkills[skill]=[this.additionalSkills[skill]];
							}
						}
						else{
							this.removeAdditionalSkill(skill);
							this.additionalSkills[skill]=[];
						}
					}
					else{
						this.additionalSkills[skill]=[];
					}
					if(typeof skills=='string'){
						skills=[skills];
					}
					for(var i=0;i<skills.length;i++){
						this.addSkill(skills[i],null,true);
						this.skills.remove(skills[i]);
						this.additionalSkills[skill].push(skills[i]);
					}
					this.checkConflict();
					return this;
				},
				removeAdditionalSkill:function(skill,target){
					if(this.additionalSkills[skill]){
						var additionalSkills=this.additionalSkills[skill];
						if(Array.isArray(additionalSkills)&&typeof target=='string'){
							if(additionalSkills.contains(target)){
								additionalSkills.remove(target);
								this.removeSkill(target);
							}
						}
						else{
							delete this.additionalSkills[skill];
							if(typeof additionalSkills=='string'){
								this.removeSkill(additionalSkills);
							}
							else if(Array.isArray(additionalSkills)){
								for(var i=0;i<additionalSkills.length;i++){
									this.removeSkill(additionalSkills[i]);
								}
							}
						}
					}
					return this;
				},
				awakenSkill:function(skill,nounmark){
					if(!nounmark) this.unmarkSkill(skill);
					this.disableSkill(skill+'_awake',skill);
					this.awakenedSkills.add(skill);
					if(this.storage[skill]===false) this.storage[skill]=true;
					return this;
				},
				restoreSkill:function(skill,nomark){
					if(this.storage[skill]===true) this.storage[skill]=false;
					this.awakenedSkills.remove(skill);
					this.enableSkill(skill+'_awake',skill);
					if(!nomark) this.markSkill(skill);
					return this;
				},
				disableSkill:function(skill,skills){
					if(typeof skills=='string'){
						if(!this.disabledSkills[skills]){
							this.disabledSkills[skills]=[];
							var info=get.info(skills);
							if(info.ondisable&&info.onremove){
								info.onremove(this);
							}
						}
						this.disabledSkills[skills].add(skill);
						var group=lib.skill[skills].group;
						if(typeof group=='string'||Array.isArray(group)){
							this.disableSkill(skill,group);
						}
					}
					else if(Array.isArray(skills)){
						for(var i=0;i<skills.length;i++){
							this.disableSkill(skill,skills[i]);
						}
					}
					return this;
				},
				enableSkill:function(skill){
					for(var i in this.disabledSkills){
						this.disabledSkills[i].remove(skill);
						if(this.disabledSkills[i].length==0){
							delete this.disabledSkills[i];
						}
					}
					return this;
				},
				checkMarks:function(){
					var skills=this.getSkills();
					game.expandSkills(skills);
					for(var i in this.marks){
						if(!skills.contains(i)&&!this.marks[i].info.fixed){
							this.unmarkSkill(i);
						}
					}
					return this;
				},
				addEquipTrigger:function(card){
					if(card){
						var info=get.info(card);
						if(info.skills){
							for(var j=0;j<info.skills.length;j++){
								this.addSkillTrigger(info.skills[j]);
							}
						}
					}
					else{
						var es=this.getCards('e');
						for(var i=0;i<es.length;i++){
							this.addEquipTrigger(es[i]);
						}
					}
					return this;
				},
				removeEquipTrigger:function(card){
					if(card){
						var info=get.info(card);
						if(info.skills){
							for(var j=0;j<info.skills.length;j++){
								this.removeSkillTrigger(info.skills[j]);
							}
						}
						if(info.clearLose&&typeof info.onLose=='function'){
							var next=game.createEvent('lose_'+card.name);
							next.setContent(info.onLose);
							next.player=this;
							next.card=card;
						}
					}
					else{
						var es=this.getCards('e');
						for(var i=0;i<es.length;i++){
							this.removeEquipTrigger(es[i]);
						}
					}
					return this;
				},
				removeSkillTrigger:function(skill,triggeronly){
					var info=lib.skill[skill];
					if(!info) return;
					if(typeof info.group=='string'){
						this.removeSkillTrigger(info.group);
					}
					else if(Array.isArray(info.group)){
						for(var i=0;i<info.group.length;i++){
							this.removeSkillTrigger(info.group[i]);
						}
					}
					if(!triggeronly) this.initedSkills.remove(skill);
					if(info.trigger){
						var playerid=this.playerid;
						var removeTrigger=function(i,evt){
							if(i=='global'){
								for(var j in lib.hook.globaltrigger){
									if(lib.hook.globaltrigger[j][playerid]){
										lib.hook.globaltrigger[j][playerid].remove(skill);
										if(lib.hook.globaltrigger[j][playerid].length==0){
											delete lib.hook.globaltrigger[j][playerid];
										}
										if(get.is.empty(lib.hook.globaltrigger[j])){
											delete lib.hook.globaltrigger[j];
										}
									}
								}
							}
							else{
								var name=playerid+'_'+i+'_'+evt;
								if(lib.hook[name]){
									lib.hook[name].remove(skill);
									if(lib.hook[name].length==0){
										delete lib.hook[name];
									}
								}
							}
						}
						for(var i in info.trigger){
							if(typeof info.trigger[i]=='string'){
								removeTrigger(i,info.trigger[i]);
							}
							else if(Array.isArray(info.trigger[i])){
								for(var j=0;j<info.trigger[i].length;j++){
									removeTrigger(i,info.trigger[i][j]);
								}
							}
						}
					}
					if(info.hookTrigger){
						if(this._hookTrigger){
							this._hookTrigger.remove(skill);
							if(!this._hookTrigger.length){
								delete this._hookTrigger;
							}
						}
					}
					return this;
				},
				removeSkill:function(skill){
					if(!skill) return;
					if(Array.isArray(skill)){
						for(var i=0;i<skill.length;i++){
							this.removeSkill(skill[i]);
						}
					}
					else{
						var info=lib.skill[skill];
						if(info&&info.fixed&&arguments[1]!==true) return skill;
						this.unmarkSkill(skill);
						game.broadcastAll(function(player,skill){
							player.skills.remove(skill);
							player.hiddenSkills.remove(skill);
						},this,skill);
						this.checkConflict(skill);
						delete this.tempSkills[skill];
						if(info){
							if(info.onremove){
								if(typeof info.onremove=='function'){
									info.onremove(this,skill);
								}
								else if(typeof info.onremove=='string'){
									if(info.onremove=='storage'){
										delete this.storage[skill];
									}
									else{
										var cards=this.storage[skill];
										if(get.itemtype(cards)=='card'){
											cards=[cards];
										}
										if(get.itemtype(cards)=='cards'){
											if(this.onremove=='discard'){
												this.$throw(cards);
											}
											if(this.onremove=='discard'||this.onremove=='lose'){
												game.cardsDiscard(cards);
												delete this.storage[skill];
											}
										}
									}
								}
								else if(Array.isArray(info.onremove)){
									for(var i=0;i<info.onremove.length;i++){
										delete this.storage[info.onremove[i]];
									}
								}
								else if(info.onremove===true){
									delete this.storage[skill];
								}
							}
							this.removeSkillTrigger(skill);
							if(!info.keepSkill){
								this.removeAdditionalSkill(skill);
							}
						}
						this.enableSkill(skill+'_awake');
					}
					return skill;
				},
				addTempSkill:function(skill,expire,checkConflict){
					if(this.hasSkill(skill)&&this.tempSkills[skill]==undefined) return;
					this.addSkill(skill,checkConflict,true);
					this.skills.remove(skill);
	
					if(!expire){
						expire='phaseAfter';
					}
					this.tempSkills[skill]=expire;
	
					if(typeof expire=='string'){
						lib.hookmap[expire]=true;
					}
					else if(Array.isArray(expire)){
						for(var i=0;i<expire.length;i++){
							lib.hookmap[expire[i]]=true;
						}
					}
					else if(get.objtype(expire)=='object'){
						var roles=['player','source','target'];
						for(var i=0;i<roles.length;i++){
							if(typeof expire[roles[i]]=='string'){
								lib.hookmap[expire[roles[i]]]=true;
							}
							else if(Array.isArray(expire[roles[i]])){
								for(var j=0;j<expire[roles[i]].length;j++){
									lib.hookmap[expire[roles[i]][j]]=true;
								}
							}
						}
					}
	
					for(var i in expire){
						if(typeof expire[i]=='string'){
							lib.hookmap[expire[i]]=true;
						}
						else if(Array.isArray(expire[i])){
							for(var j=0;j<expire.length;j++){
								lib.hookmap[expire[i][j]]=true;
							}
						}
					}
					return skill;
				},
				attitudeTo:function(target){
					if(typeof get.attitude=='function') return get.attitude(this,target);
					return 0;
				},
				clearSkills:function(all){
					var list=[];
					var exclude=[];
					for(var i=0;i<arguments.length;i++){
						exclude.push(arguments[i]);
					}
					for(i=0;i<this.skills.length;i++){
						if(!all&&lib.skill[this.skills[i]].temp) continue;
						if(!exclude.contains(this.skills[i])){
							list.push(this.skills[i]);
						}
					}
					if(all){
						for(var i in this.additionalSkills){
							this.removeAdditionalSkill(i);
						}
					}
					this.removeSkill(list);
					this.checkConflict();
					this.checkMarks();
					return list;
				},
				checkConflict:function(skill){
					if(skill){
						if(this.forbiddenSkills[skill]){
							delete this.forbiddenSkills[skill];
						}
						else{
							for(var i in this.forbiddenSkills){
								if(this.forbiddenSkills[i].remove(skill)){
									if(!this.forbiddenSkills[i].length){
										delete this.forbiddenSkills[i];
									}
								}
							}
						}
					}
					else{
						this.forbiddenSkills={};
						var forbid=[];
						var getName=function(arr){
							var str='';
							for(var i=0;i<arr.length;i++){
								str+=arr[i]+'+';
							}
							return str.slice(0,str.length-1);
						}
						var forbidlist=lib.config.forbid.concat(lib.config.customforbid);
						var skills=this.getSkills();
						for(var i=0;i<forbidlist.length;i++){
							if(lib.config.customforbid.contains(forbidlist[i])||
								!lib.config.forbidlist.contains(getName(forbidlist[i]))){
								for(var j=0;j<forbidlist[i].length;j++){
									if(!skills.contains(forbidlist[i][j])) break;
								}
								if(j==forbidlist[i].length){
									forbid.push(forbidlist[i]);
								}
							}
						}
						for(var i=0;i<forbid.length;i++){
							if(forbid[i][1]||this.name2){
								this.forbiddenSkills[forbid[i][0]]=this.forbiddenSkills[forbid[i][0]]||[];
								if(forbid[i][1]){
									this.forbiddenSkills[forbid[i][0]].add(forbid[i][1]);
								}
							}
						}
					}
				},
				getStat:function(key){
					if(!key) return this.stat[this.stat.length-1];
					return this.stat[this.stat.length-1][key];
				},
				queue:function(time){
					if(time==false){
						clearTimeout(this.queueTimeout);
						this.queueCount=0;
						return;
					}
					if(time==undefined) time=500;
					var player=this;
					player.queueCount++;
					this.queueTimeout=setTimeout(function(){
						player.queueCount--;
						if(player.queueCount==0){
							player.style.transform='';
							player.node.avatar.style.transform='';
							player.node.avatar2.style.transform='';
							if(game.chess){
								ui.placeChess(player,player.dataset.position);
							}
							if(player==game.me) ui.me.removeAttribute('style');
						}
					},time)
				},
				getCardUsable:function(card,pure){
					var player=this;
					if(typeof card=='string'){
						card={name:card};
					}
					card=get.autoViewAs(card,null,player);
					var num=get.info(card).usable;
					if(typeof num=='function') num=num(card,player);
					num=game.checkMod(card,player,num,'cardUsable',player);
					if(typeof num!='number') return Infinity;
					if(!pure&&_status.currentPhase==player){
						return num-player.countUsed(card);
					}
					return num;
				},
				getAttackRange:function(raw){
					var player=this;
					var range=0;
					if(raw) range=game.checkMod(player,player,range,'globalFrom',player);
					range=game.checkMod(player,player,range,'attackFrom',player);
					var equips=player.getCards('e');
					for(var i=0;i<equips.length;i++){
						var info=get.info(equips[i]).distance;
						if(!info) continue;
						if(raw&&info.globalFrom){
							range+=info.globalFrom;
						}
						if(info.attackFrom){
							range+=info.attackFrom;
						}
					}
					return (1-range);
				},
				getGlobalFrom:function(){
					var player=this;
					var range=0;
					range=game.checkMod(player,player,range,'globalFrom',player);
					var equips=player.getCards('e');
					for(var i=0;i<equips.length;i++){
						var info=get.info(equips[i]).distance;
						if(!info) continue;
						if(info.globalFrom){
							range+=info.globalFrom;
						}
					}
					return (-range);
				},
				getGlobalTo:function(){
					var player=this;
					var range=0;
					range=game.checkMod(player,player,range,'globalTo',player);
					var equips=player.getCards('e');
					for(var i=0;i<equips.length;i++){
						var info=get.info(equips[i]).distance;
						if(!info) continue;
						if(info.globalTo){
							range+=info.globalTo;
						}
					}
					return (range);
				},
				getHandcardLimit:function(){
					return Math.max(0,game.checkMod(this,this.hp,'maxHandcard',this));
				},
				getEnemies:function(func){
					var player=this;
					var targets;
					var mode=get.mode();
					if(mode=='identity'){
						var num=get.population('fan');
						switch(player.identity){
							case 'zhu':case 'zhong':case 'mingzhong':targets=game.filterPlayer(function(target){
								if(func&&!func(target)) return false;
								if(num>=3) return target.identity=='fan';
								return target.identity=='nei'||target.identity=='fan';
							});break;
							case 'nei':targets=game.filterPlayer(function(target){
								if(func&&!func(target)) return false;
								if(num>=3) return target.identity=='fan';
								if(game.players.length==2) return target!=player;
								return target.identity=='zhong'||target.identity=='mingzhong'||target.identity=='fan';
							});break;
							case 'fan':targets=game.filterPlayer(function(target){
								if(func&&!func(target)) return false;
								return target.identity!='fan';
							});break;
						}
					}
					else if(mode=='guozhan'){
						if(player.identity=='ye'){
							targets=game.filterPlayer(function(target){
								if(func&&!func(target)) return false;
								return true;
							});
						}
						else{
							var group=lib.character[player.name1][1];
							targets=game.filterPlayer(function(target){
								if(func&&!func(target)) return false;
								return target.identity=='ye'||lib.character[target.name1][1]!=group;
							});
						}
					}
					else if(mode=='doudizhu'){
						targets=game.filterPlayer(function(target){
							if(func&&!func(target)) return false;
							return target.identity!=player.identity;
						});
					}
					else{
						targets=game.filterPlayer(function(target){
							if(func&&!func(target)) return false;
							return target.side!=player.side;
						});
					}
					targets.remove(player);
					return targets;
				},
				getFriends:function(func){
					var player=this;
					var targets;
					var mode=get.mode();
					var self=false;
					if(func===true){
						func=null;
						self=true;
					}
					if(mode=='identity'){
						switch(player.identity){
							case 'zhu':case 'zhong':case 'mingzhong':targets=game.filterPlayer(function(target){
								if(func&&!func(target)) return false;
								return ['zhu','zhong','mingzhong'].contains(target.identity);
							});break;
							case 'nei':targets=[];break;
							case 'fan':targets=game.filterPlayer(function(target){
								if(func&&!func(target)) return false;
								return target.identity=='fan';
							});break;
						}
					}
					else if(mode=='guozhan'){
						if(player.identity=='ye'){
							targets=[];
						}
						else{
							var group=lib.character[player.name1][1];
							targets=game.filterPlayer(function(target){
								if(func&&!func(target)) return false;
								return target.identity!='ye'&&lib.character[target.name1][1]==group;
							});
						}
					}
					else if(mode=='doudizhu'){
						targets=game.filterPlayer(function(target){
							if(func&&!func(target)) return false;
							return target.identity==player.identity;
						});
					}
					else{
						targets=game.filterPlayer(function(target){
							if(func&&!func(target)) return false;
							return target.side==player.side;
						});
					}
					if(self){
						targets.add(player);
					}
					else{
						targets.remove(player);
					}
					return targets;
				},
				isEnemyOf:function(){
					return !this.isFriendOf.apply(this,arguments);
				},
				isFriendOf:function(player){
					if(get.mode()=='guozhan'){
						if(this==player) return true;
						if(this.identity=='unknown'||this.identity=='ye') return false;
						if(player.identity=='unknown'||player.identity=='ye') return false;
						return this.identity==player.identity;
					}
					if(get.mode()=='doudizhu'){
						return this.identity==player.identity;
					}
					if(this.side!=undefined&&typeof player.side=='boolean'){
						return this.side==player.side;
					}
					return this==player;
				},
				isFriendsOf:function(player){
					return player.getFriends(true).contains(this);
				},
				isEnemiesOf:function(player){
					return player.getEnemies().contains(this);
				},
				isAlive:function(){
					return this.classList.contains('dead')==false;
				},
				isDead:function(){
					return this.classList.contains('dead');
				},
				isDying:function(){
					return _status.dying.contains(this)&&this.hp<=0&&this.isAlive();
				},
				isDamaged:function(){
					return this.hp<this.maxHp;
				},
				isHealthy:function(){
					return this.hp==this.maxHp;
				},
				isMaxHp:function(equal){
					for(var i=0;i<game.players.length;i++){
						if(game.players[i].isOut()||game.players[i]==this) continue;
						if(equal){
							if(game.players[i].hp>=this.hp) return false;
						}
						else{
							if(game.players[i].hp>this.hp) return false;
						}
					}
					return true;
				},
				isMinHp:function(equal){
					for(var i=0;i<game.players.length;i++){
						if(game.players[i].isOut()||game.players[i]==this) continue;
						if(equal){
							if(game.players[i].hp<=this.hp) return false;
						}
						else{
							if(game.players[i].hp<this.hp) return false;
						}
					}
					return true;
				},
				isMaxCard:function(equal){
					var nh=this.countCards('he');
					for(var i=0;i<game.players.length;i++){
						if(game.players[i].isOut()||game.players[i]==this) continue;
						if(equal){
							if(game.players[i].countCards('he')>=nh) return false;
						}
						else{
							if(game.players[i].countCards('he')>nh) return false;
						}
					}
					return true;
				},
				isMinCard:function(equal){
					var nh=this.countCards('he');
					for(var i=0;i<game.players.length;i++){
						if(game.players[i].isOut()||game.players[i]==this) continue;
						if(equal){
							if(game.players[i].countCards('he')<=nh) return false;
						}
						else{
							if(game.players[i].countCards('he')<nh) return false;
						}
					}
					return true;
				},
				isMaxHandcard:function(equal){
					var nh=this.countCards('h');
					for(var i=0;i<game.players.length;i++){
						if(game.players[i].isOut()||game.players[i]==this) continue;
						if(equal){
							if(game.players[i].countCards('h')>=nh) return false;
						}
						else{
							if(game.players[i].countCards('h')>nh) return false;
						}
					}
					return true;
				},
				isMinHandcard:function(equal){
					var nh=this.countCards('h');
					for(var i=0;i<game.players.length;i++){
						if(game.players[i].isOut()||game.players[i]==this) continue;
						if(equal){
							if(game.players[i].countCards('h')<=nh) return false;
						}
						else{
							if(game.players[i].countCards('h')<nh) return false;
						}
					}
					return true;
				},
				isMaxEquip:function(equal){
					var nh=this.countCards('e');
					for(var i=0;i<game.players.length;i++){
						if(game.players[i].isOut()||game.players[i]==this) continue;
						if(equal){
							if(game.players[i].countCards('e')>=nh) return false;
						}
						else{
							if(game.players[i].countCards('e')>nh) return false;
						}
					}
					return true;
				},
				isMinEquip:function(equal){
					var nh=this.countCards('e');
					for(var i=0;i<game.players.length;i++){
						if(game.players[i].isOut()||game.players[i]==this) continue;
						if(equal){
							if(game.players[i].countCards('e')<=nh) return false;
						}
						else{
							if(game.players[i].countCards('e')<nh) return false;
						}
					}
					return true;
				},
				isLinked:function(){
					if(get.is.linked2(this)){
						return this.classList.contains('linked2');
					}
					return this.classList.contains('linked');
				},
				isTurnedOver:function(){
					return this.classList.contains('turnedover');
				},
				isOut:function(){
					return this.classList.contains('out');
				},
				isMin:function(distance){
					if(distance&&lib.config.mode!='stone') return false;
					if(this.forcemin) return true;
					return this.classList.contains('minskin')&&!game.chess;
				},
				isIn:function(){
					return this.classList.contains('dead')==false&&this.classList.contains('out')==false&&!this.removed;
				},
				isUnseen:function(num){
					switch(num){
						case 0:return this.classList.contains('unseen');
						case 1:return this.classList.contains('unseen2');
						case 2:return this.classList.contains('unseen')||this.classList.contains('unseen2');
						default:return this.classList.contains('unseen')&&this.classList.contains('unseen2');
					}
				},
				isUnderControl:function(self,me){
					me=me||game.me;
					if(this.isMad()) return false;
					if(this===me){
						if(self) return true;
						return false;
					}
					if(_status.connectMode) return false;
					if(lib.config.mode=='versus'){
						if(_status.mode=='three') return this.side==me.side;
						if(_status.mode=='standard') return lib.storage.single_control&&this.side==me.side;
						if(_status.mode=='four') return get.config('four_phaseswap')&&this.side==me.side;
						if(_status.mode=='two') return get.config('two_phaseswap')&&this.side==me.side;
						return false;
					}
					else if(lib.config.mode=='boss'){
						if(me.side) return false;
						return this.side==me.side&&get.config('single_control');
					}
					else if(game.chess){
						if(lib.config.mode=='chess'){
							if(_status.mode=='combat'&&!get.config('single_control')) return false;
						}
						return this.side==me.side;
					}
					return false;
				},
				isOnline:function(){
					if(this.ws&&lib.node&&!this.ws.closed&&this.ws.inited&&!this.isAuto){
						return true;
					}
					return false;
				},
				isOnline2:function(){
					if(this.ws&&lib.node&&!this.ws.closed){
						return true;
					}
					return false;
				},
				isOffline:function(){
					if(this.ws&&lib.node&&this.ws.closed){
						return true;
					}
					return false;
				},
				checkShow:function(skill,showonly){
					var sourceSkill=get.info(skill);
					var noshow=false;
					if(sourceSkill&&sourceSkill.sourceSkill){
						skill=sourceSkill.sourceSkill;
					}
					if(lib.skill.global.contains(skill)) return false;
					if(get.mode()!='guozhan'||game.expandSkills(this.getSkills()).contains(skill)){
						if(showonly){
							return false;
						}
						else{
							noshow=true;
						}
					}
					var unseen0=this.isUnseen(0);
					var name1=this.name1||this.name;
					if(lib.character[name1]&&(!showonly||unseen0)){
						var skills=game.expandSkills(lib.character[name1][3].slice(0));
						if(skills.contains(skill)){
							if(!noshow&&this.isUnseen(0)) this.showCharacter(0);
							return 'main';
						}
					}
					var unseen1=this.isUnseen(1);
					var name2=this.name2;
					if(lib.character[name2]&&(!showonly||unseen1)){
						var skills=game.expandSkills(lib.character[name2][3].slice(0));
						if(skills.contains(skill)){
							if(!noshow&&this.isUnseen(1)) this.showCharacter(1);
							return 'vice';
						}
					}
					return false;
				},
				needsToDiscard:function(num){
					if(typeof num!='number') num=0;
					var hs=this.getCards('h');
					num+=hs.length;
					for(var i=0;i<hs.length;i++){
						if(game.checkMod(hs[i],this,false,'ignoredHandcard',this)==true){
							num--;
						}
					}
					return Math.max(0,num-this.getHandcardLimit());
				},
				distanceTo:function(target,method){
					return get.distance(this,target,method);
				},
				distanceFrom:function(target,method){
					return get.distance(target,this,method);
				},
				hasSkill:function(skill,arg2,arg3,arg4){
					return game.expandSkills(this.getSkills(arg2,arg3,arg4)).contains(skill);
				},
				hasStockSkill:function(skill,arg1,arg2,arg3){
					return game.expandSkills(this.getStockSkills(arg1,arg2,arg3)).contains(skill);
				},
				hasZhuSkill:function(skill,player){
					if(!this.hasSkill(skill)) return false;
					var mode=get.mode();
					if(mode=='identity'||(mode=='versus'&&_status.mode=='four')){
						if(mode!='identity'){
							if(player&&this.side!=player.side) return false;
						}
						if(this.isZhu) return true;
						for(var i in this.storage){
							if(i.indexOf('zhuSkill_')==0&&this.storage[i].contains(skill)) return true;
						}
					}
					return false;
				},
				hasGlobalTag:function(tag,arg){
					var skills=lib.skill.global.slice(0);
					game.expandSkills(skills);
					for(var i=0;i<skills.length;i++){
						var info=lib.skill[skills[i]];
						if(info&&info.ai){
							if(info.ai.skillTagFilter&&info.ai[tag]&&
								info.ai.skillTagFilter(this,tag,arg)===false) continue;
							if(typeof info.ai[tag]=='string'){
								if(info.ai[tag]==arg) return true;
							}
							else if(info.ai[tag]){
								return true;
							}
						}
					}
					return false;
				},
				hasSkillTag:function(tag,hidden,arg,globalskill){
					var skills=this.getSkills(hidden);
					if(globalskill){
						skills.addArray(lib.skill.global);
					}
					game.expandSkills(skills);
					for(var i=0;i<skills.length;i++){
						var info=lib.skill[skills[i]];
						if(info&&info.ai){
							if(info.ai.skillTagFilter&&info.ai[tag]&&
								info.ai.skillTagFilter(this,tag,arg)===false) continue;
							if(typeof info.ai[tag]=='string'){
								if(info.ai[tag]==arg) return true;
							}
							else if(info.ai[tag]){
								return true;
							}
						}
					}
					return false;
				},
				hasJudge:function(name){
					if(name&&typeof name=='object'){
						name=name.viewAs||name.name;
					}
					var judges=this.node.judges.childNodes;
					for(var i=0;i<judges.length;i++){
						if(judges[i].classList.contains('removing')) continue;
						if((judges[i].viewAs||judges[i].name)==name){
							return true;
						}
					}
					return false;
				},
				hasFriend:function(){
					for(var i=0;i<game.players.length;i++){
						if(game.players[i].isOut()) continue;
						if(game.players[i]!=this&&get.attitude(game.players[i],this)>0){
							return true;
						}
					}
					return false;
				},
				hasUnknown:function(num){
					var mode=get.mode();
					if(typeof num!='number'){
						num=0;
					}
					if(mode=='identity'||mode=='guozhan'){
						for(var i=0;i<game.players.length;i++){
							if(game.players[i].ai.shown==0&&game.players[i]!=this){
								num--;
								if(num<=0){
									return true;
								}
							}
						}
					}
					return false;
				},
				isUnknown:function(player){
					var mode=get.mode();
					if(mode=='identity'||mode=='guozhan'){
						if(this.ai.shown==0&&this!=player){
							return true;
						}
					}
					return false;
				},
				hasWuxie:function(){
					if(this.countCards('h','wuxie')) return true;
					var skills=this.getSkills(true).concat(lib.skill.global);
					game.expandSkills(skills);
					for(var i=0;i<skills.length;i++){
						var ifo=get.info(skills[i]);
						if(ifo.viewAs&&ifo.viewAs.name=='wuxie'){
							if(!ifo.viewAsFilter||ifo.viewAsFilter(this)){
								return true;
							}
						}
						else{
							var hiddenCard=get.info(skills[i]).hiddenCard;
							if(typeof hiddenCard=='function'&&hiddenCard(this,'wuxie')){
								return true;
							}
						}
					}
					return false;
				},
				hasSha:function(respond,noauto){
					if(this.countCards('h','sha')) return true;
					if(this.countCards('h','hufu')) return true;
					if(!noauto&&this.countCards('h','yuchanqian')) return true;
					if(this.hasSkillTag('respondSha',true,respond?'respond':'use',true)) return true;
					return false;
				},
				hasShan:function(){
					if(this.countCards('h','shan')) return true;
					if(this.countCards('h','hufu')) return true;
					if(this.hasSkillTag('respondShan',true,null,true)) return true;
					return false;
				},
				mayHaveShan:function(){
					return this.hasShan();
					// modify: later
				},
				hasCard:function(name,position){
					if(typeof name=='function'){
						var hs=this.getCards(position);
						for(var i=0;i<hs.length;i++){
							if(name(hs[i])) return true;
						}
					}
					else{
						if(this.countCards(position,name)) return true;
						var mn=this.getEquip('muniu');
						if(mn&&mn.cards&&mn.cards.length){
							for(var i=0;i<mn.cards.length;i++){
								if(mn.cards[i].name==name) return true;
							}
						}
					}
					return false;
				},
				canEquip:function(name,replace){
					if(get.type(name)=='card'){
						name=get.equiptype(name);
					}
					var range=get.subtype(name);
					if(this.isDisabled(range)) return false;
					if(['equip3','equip4'].contains(range)&&!this.isEmpty(6)) return false;
					if(!replace&&!this.isEmpty(range)) return false;
					return true;
				},
				getEquip:function(name){
					var es=this.getCards('e');
					if(typeof name=='object'&&get.info(name)){
						name=get.info(name).subtype;
						if(name){
							name=parseInt(name[5]);
						}
					}
					else if(typeof name=='string'&&name.indexOf('equip')==0&&name.length==6){
						name=parseInt(name[5]);
					}
					if(!name){
						return null;
					}
					for(var i=0;i<es.length;i++){
						if(typeof name==='number'){
							if(get.info(es[i]).subtype==='equip'+name){
								return es[i];
							}
						}
						else{
							if(es[i].name===name) return es[i];
							var source=get.info(es[i]).source;
							if(Array.isArray(source)&&source.contains(name)){
								return es[i];
							}
						}
					}
					return null;
				},
				getJudge:function(name){
					var judges=this.node.judges.childNodes;
					for(var i=0;i<judges.length;i++){
						if(judges[i].classList.contains('removing')) continue;
						if((judges[i].viewAs||judges[i].name)==name){
							return judges[i];
						}
					}
					return null;
				},
				$drawAuto:function(cards,target){
					if(this.isUnderControl(true,target)){
						this.$draw(cards);
					}
					else{
						this.draw(cards.length);
					}
				},
				$draw:function(num,init,config){
					if(init!==false&&init!=='nobroadcast'){
						game.broadcast(function(player,num,init,config){
							player.$draw(num,init,config)
						},this,num,init,config);
					}
					var cards,node;
					if(get.itemtype(num)=='cards'){
						cards=num;
						num=cards.length;
					}
					else if(get.itemtype(num)=='card'){
						cards=[num];
						num=1;
					}
					if(init!==false){
						if(cards){
							game.addVideo('drawCard',this,get.cardsInfo(cards));
						}
						else{
							game.addVideo('draw',this,num);
						}
					}
					if(cards){
						cards=cards.slice(0);
						node=cards.shift().copy('thrown','drawingcard');
					}
					else{
						node=ui.create.div('.card.thrown.drawingcard');
					}
					node.fixed=true;
					node.hide();
	
					var dx,dy;
					if(game.chess){
						var rect=this.getBoundingClientRect();
	
						if(rect.left<=80){
							dx=-10;
							if(rect.top<=80){
								dy=-10;
							}
							else if(rect.top+rect.height+80>=ui.chessContainer.offsetHeight){
								dy=10;
							}
							else{
								dy=0;
							}
						}
						else if(rect.left+rect.width+80>=ui.chessContainer.offsetWidth){
							dx=10;
							if(rect.top<=80){
								dy=-10;
							}
							else if(rect.top+rect.height+80>=ui.chessContainer.offsetHeight){
								dy=10;
							}
							else{
								dy=0;
							}
						}
						else if(rect.top<=80){
							dx=0;
							dy=-10;
						}
						else if(rect.top+rect.height+80>=ui.chessContainer.offsetHeight){
							dx=0;
							dy=10;
						}
						else{
							dx=rect.left+this.offsetWidth/2-ui.arena.offsetWidth/2;
							dy=rect.top+this.offsetHeight/2-ui.arena.offsetHeight/2;
						}
	
						var coeff=240/Math.sqrt(dx*dx+dy*dy);
						dx*=coeff;
						dy*=coeff;
	
						node.style.left=(this.getLeft()+this.offsetWidth/2-52-dx)+'px';
						node.style.top=(this.getTop()+this.offsetHeight/2-52-dy)+'px';
						this.parentNode.appendChild(node);
					}
					else{
						this.parentNode.appendChild(node);
						node.style.left='calc(50% - 52px)';
						node.style.top='calc(50% - 52px)';
	
						dx=this.getLeft()+this.offsetWidth/2-52-node.offsetLeft;
						dy=this.getTop()+this.offsetHeight/2-52-node.offsetTop;
	
						if(get.is.mobileMe(this)){
							dx+=get.cardOffset();
							if(ui.arena.classList.contains('oblongcard')){
								dy-=16;
							}
						}
					}
					node.style.transitionDuration='0.8s';
					ui.refresh(node);
					if(typeof num=='number'&&init!==false){
						config={
							total:num,
							current:1
						}
					}
					if(config&&config.total>1){
						var total=config.total,current=config.current;
						var dxtotal;
						if(total<=5){
							dxtotal=Math.min(80,(total-1)*20);
							dx+=-dxtotal+2*dxtotal*(current-1)/(total-1)
						}
						else{
							var total2=Math.floor(total/2);
							if(current<=total2){
								total=total2;
								dy-=20;
							}
							else{
								current-=total2;
								total-=total2;
								dy+=20;
							}
							dxtotal=Math.min(80,(total-1)*20);
							dx+=-dxtotal+2*dxtotal*(current-1)/(total-1)
						}
						config.current++;
					}
					if(node.style.transform&&node.style.transform!='none'&&node.style.transform.indexOf('translate')==-1){
						node.style.transform+=' translate('+dx+'px,'+dy+'px)';
					}
					else{
						node.style.transform='translate('+dx+'px,'+dy+'px)';
					}
					node.show();
	
					node.listenTransition(function(){
						node.style.transitionDuration='0.5s';
						ui.refresh(node);
						node.delete();
					});
					var that=this;
					if(num&&num>1){
						if(config&&config.total>1){
							setTimeout(function(){
								if(cards){
									that.$draw(cards,false,config)
								}
								else{
									that.$draw(num-1,false,config)
								}
							},50)
						}
						else{
							setTimeout(function(){
								if(cards){
									that.$draw(cards,false,config)
								}
								else{
									that.$draw(num-1,false,config)
								}
							},200);
						}
					}
				},
				$compareMultiple:function(card1,targets,cards){
					game.broadcast(function(player,card1,targets,cards){
						player.$compareMultiple(card1,targets,cards);
					},this,card1,targets,cards);
					game.addVideo('compareMultiple',this,[get.cardInfo(card1),get.targetsInfo(targets),get.cardsInfo(cards)]);
					var player=this;
					var node1=player.$throwxy2(card1,
						'calc(50% - 52px)','calc(50% + 10px)','perspective(600px) rotateY(180deg)',true
					);
					if(lib.config.cardback_style!='default'){
						node1.style.transitionProperty='none';
						ui.refresh(node1);
						node1.classList.add('infohidden');
						ui.refresh(node1);
						node1.style.transitionProperty='';
					}
					else{
						node1.classList.add('infohidden');
					}
	
					node1.style.transform='perspective(600px) rotateY(180deg) translateX(0)';
					var onEnd01=function(){
						node1.removeEventListener('webkitTransitionEnd',onEnd01);
						setTimeout(function(){
							node1.style.transition='all ease-in 0.3s';
							node1.style.transform='perspective(600px) rotateY(270deg) translateX(52px)';
							var onEnd=function(){
								node1.classList.remove('infohidden');
								node1.style.transition='all 0s';
								ui.refresh(node1);
								node1.style.transform='perspective(600px) rotateY(-90deg) translateX(52px)';
								ui.refresh(node1);
								node1.style.transition='';
								ui.refresh(node1);
								node1.style.transform='';
								node1.removeEventListener('webkitTransitionEnd',onEnd);
							}
							node1.listenTransition(onEnd);
						},300);
					};
					node1.listenTransition(onEnd01);
	
					setTimeout(function(){
						var left0=-targets.length*52-(targets.length-1)*8;
						for(var i=0;i<targets.length;i++){
							(function(target,card2,i){
								var left=left0+i*120;
								var node2;
								if(left<0){
									node2=target.$throwxy2(card2,
										'calc(50% - '+(-left)+'px)','calc(50% - 114px)','perspective(600px) rotateY(180deg)',true
									);
								}
								else{
									node2=target.$throwxy2(card2,
										'calc(50% + '+left+'px)','calc(50% - 114px)','perspective(600px) rotateY(180deg)',true
									);
								}
								if(lib.config.cardback_style!='default'){
									node2.style.transitionProperty='none';
									ui.refresh(node2);
									node2.classList.add('infohidden');
									ui.refresh(node2);
									node2.style.transitionProperty='';
								}
								else{
									node2.classList.add('infohidden');
								}
								node2.style.transform='perspective(600px) rotateY(180deg) translateX(0)';
								var onEnd02=function(){
									node2.removeEventListener('webkitTransitionEnd',onEnd02);
									setTimeout(function(){
										node2.style.transition='all ease-in 0.3s';
										node2.style.transform='perspective(600px) rotateY(270deg) translateX(52px)';
										var onEnd=function(){
											node2.classList.remove('infohidden');
											node2.style.transition='all 0s';
											ui.refresh(node2);
											node2.style.transform='perspective(600px) rotateY(-90deg) translateX(52px)';
											ui.refresh(node2);
											node2.style.transition='';
											ui.refresh(node2);
											node2.style.transform='';
											node2.removeEventListener('webkitTransitionEnd',onEnd);
										}
										node2.listenTransition(onEnd);
									},200);
								};
								node2.listenTransition(onEnd02);
							}(targets[i],cards[i],i))
						}
					},200);
				},
				$compare:function(card1,target,card2){
					game.broadcast(function(player,target,card1,card2){
						player.$compare(card1,target,card2);
					},this,target,card1,card2);
					game.addVideo('compare',this,[get.cardInfo(card1),target.dataset.position,get.cardInfo(card2)]);
					var player=this;
					var node1=player.$throwxy2(card1,
						'calc(50% - 114px)','calc(50% - 52px)','perspective(600px) rotateY(180deg)',true
					);
					if(lib.config.cardback_style!='default'){
						node1.style.transitionProperty='none';
						ui.refresh(node1);
						node1.classList.add('infohidden');
						ui.refresh(node1);
						node1.style.transitionProperty='';
					}
					else{
						node1.classList.add('infohidden');
					}
	
					node1.style.transform='perspective(600px) rotateY(180deg) translateX(0)';
					var onEnd01=function(){
						node1.removeEventListener('webkitTransitionEnd',onEnd01);
						setTimeout(function(){
							node1.style.transition='all ease-in 0.3s';
							node1.style.transform='perspective(600px) rotateY(270deg) translateX(52px)';
							var onEnd=function(){
								node1.classList.remove('infohidden');
								node1.style.transition='all 0s';
								ui.refresh(node1);
								node1.style.transform='perspective(600px) rotateY(-90deg) translateX(52px)';
								ui.refresh(node1);
								node1.style.transition='';
								ui.refresh(node1);
								node1.style.transform='';
								node1.removeEventListener('webkitTransitionEnd',onEnd);
							}
							node1.listenTransition(onEnd);
						},300);
					};
					node1.listenTransition(onEnd01);
					setTimeout(function(){
						var node2=target.$throwxy2(card2,
							'calc(50% + 10px)','calc(50% - 52px)','perspective(600px) rotateY(180deg)',true
						);
						if(lib.config.cardback_style!='default'){
							node2.style.transitionProperty='none';
							ui.refresh(node2);
							node2.classList.add('infohidden');
							ui.refresh(node2);
							node2.style.transitionProperty='';
						}
						else{
							node2.classList.add('infohidden');
						}
						node2.style.transform='perspective(600px) rotateY(180deg) translateX(0)';
						var onEnd02=function(){
							node2.removeEventListener('webkitTransitionEnd',onEnd02);
							setTimeout(function(){
								node2.style.transition='all ease-in 0.3s';
								node2.style.transform='perspective(600px) rotateY(270deg) translateX(52px)';
								var onEnd=function(){
									node2.classList.remove('infohidden');
									node2.style.transition='all 0s';
									ui.refresh(node2);
									node2.style.transform='perspective(600px) rotateY(-90deg) translateX(52px)';
									ui.refresh(node2);
									node2.style.transition='';
									ui.refresh(node2);
									node2.style.transform='';
									node2.removeEventListener('webkitTransitionEnd',onEnd);
								}
								node2.listenTransition(onEnd);
							},200);
						};
						node2.listenTransition(onEnd02);
					},200);
				},
				$throw:function(card,time,init,nosource){
					if(typeof card=='number'){
						var tmp=card;
						card=[];
						while(tmp--){
							var cardx=ui.create.card();
							cardx.classList.add('infohidden');
							cardx.classList.add('infoflip');
							card.push(cardx);
						}
					}
					if(init!==false){
						if(init!=='nobroadcast'){
							game.broadcast(function(player,card,time,init,nosource){
								player.$throw(card,time,init,nosource);
							},this,card,time,init);
						}
						if(get.itemtype(card)!='cards'){
							if(get.itemtype(card)=='card'){
								card=[card];
							}
							else{
								return;
							}
						}
						game.addVideo('throw',this,[get.cardsInfo(card),time,nosource]);
					}
					if(game.chess){
						this.chessFocus();
					}
					if(get.itemtype(card)=='cards'){
						var node;
						for(var i=0;i<card.length;i++){
							node=this.$throw(card[i],time,false,nosource);
						}
						return node;
					}
					else{
						var node;
						if(card==undefined||card.length==0) return;
						node=this.$throwordered(card.copy('thrown'),nosource);
						if(time!=undefined){
							node.fixed=true;
							setTimeout(function(){node.delete()},time);
						}
						lib.listenEnd(node);
						return node;
					}
				},
				$throwordered:function(){
					return this.$throwordered2.apply(this,arguments);
					// if(lib.config.low_performance){
					// 	return this.$throwordered2.apply(this,arguments);
					// }
					// else{
					// 	return this.$throwordered1.apply(this,arguments);
					// }
				},
				$throwordered1:function(node,nosource){
					node.classList.add('thrown');
					node.hide();
					node.style.transitionProperty='left,top,opacity,transform';
					for(var i=0;i<ui.thrown.length;i++){
						if(ui.thrown[i].parentNode!=ui.arena||
							ui.thrown[i].classList.contains('removing')){
							ui.thrown.splice(i--,1);
						}
					}
					ui.thrown.push(node);
					var uithrowns=ui.thrown.slice(0);
					var tops;
					if(game.chess){
						switch(Math.floor((ui.thrown.length-1)/4)){
							case 0:
								tops=['calc(50% - 82px)'];
								break;
							case 1:
								tops=['calc(50% - 139px)','calc(50% - 25px)'];
								break;
							case 2:
								tops=['calc(50% - 196px)','calc(50% - 82px)','calc(50% + 32px)'];
								break;
							default:
								tops=['calc(50% - 253px)','calc(50% - 139px)',
									'calc(50% - 25px)','calc(50% + 89px)'];
						}
					}
					else{
						switch(Math.floor((ui.thrown.length-1)/4)){
							case 0:
								tops=['calc(50% - 52px)'];
								break;
							case 1:
								tops=['calc(50% - 109px)','calc(50% + 5px)'];
								break;
							case 2:
								tops=['calc(50% - 166px)','calc(50% - 52px)','calc(50% + 62px)'];
								break;
							default:
								tops=['calc(50% - 223px)','calc(50% - 109px)',
									'calc(50% + 5px)','calc(50% + 119px)'];
						}
					}
					while(uithrowns.length){
						var throwns=uithrowns.splice(0,Math.min(uithrowns.length,4));
						switch(throwns.length){
							case 1:
								throwns[0].style.left='calc(50% - 52px)';
								break;
							case 2:
								throwns[0].style.left='calc(50% - 109px)';
								throwns[1].style.left='calc(50% + 5px)';
								break;
							case 3:
								throwns[0].style.left='calc(50% - 166px)';
								throwns[1].style.left='calc(50% - 52px)';
								throwns[2].style.left='calc(50% + 62px)';
								break;
							case 4:
								throwns[0].style.left='calc(50% - 223px)';
								throwns[1].style.left='calc(50% - 109px)';
								throwns[2].style.left='calc(50% + 5px)';
								throwns[3].style.left='calc(50% + 119px)';
								break;
						}
						var top;
						if(tops.length){
							top=tops.shift();
						}
						else{
							if(game.chess){
								top='calc(50% - 82px)';
							}
							else{
								top='calc(50% - 52px)';
							}
						}
						for(var i=0;i<throwns.length;i++){
							throwns[i].style.top=top;
						}
					}
					if(nosource){
						node.style.transform='scale(0)';
						node.classList.add('center');
					}
					else{
						var parseCalc=function(str){
							var per=str.slice(str.indexOf('calc(')+5,str.indexOf('%'));
							var add=str.slice(str.indexOf('%')+1,str.indexOf('px')).replace(/\s/g,'');
							return [parseInt(per),parseInt(add)];
						}
						var nx=parseCalc(node.style.left);
						var ny=parseCalc(node.style.top);
						nx=nx[0]*ui.arena.offsetWidth/100+nx[1];
						ny=ny[0]*ui.arena.offsetHeight/100+ny[1];
						var dx,dy;
						if(game.chess){
							var rect=this.getBoundingClientRect();
							dx=rect.left+this.offsetWidth/2-52-nx;
							dy=rect.top+this.offsetHeight/2-52-ny;
						}
						else{
							dx=this.getLeft()+this.offsetWidth/2-52-nx;
							dy=this.getTop()+this.offsetHeight/2-52-ny;
							if(get.is.mobileMe(this)){
								dx+=get.cardOffset();
								if(ui.arena.classList.contains('oblongcard')){
									dy-=16;
								}
							}
						}
						if(node.style.transform&&node.style.transform!='none'&&node.style.transform.indexOf('translate')==-1){
							node.style.transform+=' translate('+dx+'px,'+dy+'px)';
						}
						else{
							node.style.transform='translate('+dx+'px,'+dy+'px)';
						}
					}
					ui.arena.appendChild(node);
					ui.refresh(node);
					node.style.transform='';
					node.show();
					lib.listenEnd(node);
					return node;
				},
				$throwordered2:function(node,nosource){
					node.classList.add('thrown');
					node.classList.add('center');
					node.hide();
					node.style.transitionProperty='left,top,opacity,transform';
	
					if(nosource){
						// node.style.transform='scale(0)';
					}
					else{
						var nx=[50,-52];
						var ny=[50,-52];
						nx=nx[0]*ui.arena.offsetWidth/100+nx[1];
						ny=ny[0]*ui.arena.offsetHeight/100+ny[1];
						var dx,dy;
						if(game.chess){
							var rect=this.getBoundingClientRect();
							dx=rect.left+this.offsetWidth/2-52-nx;
							dy=rect.top+this.offsetHeight/2-52-ny;
						}
						else{
							dx=this.getLeft()+this.offsetWidth/2-52-nx;
							dy=this.getTop()+this.offsetHeight/2-52-ny;
							if(get.is.mobileMe(this)){
								dx+=get.cardOffset();
								if(ui.arena.classList.contains('oblongcard')){
									dy-=16;
								}
							}
						}
						if(node.style.transform&&node.style.transform!='none'&&node.style.transform.indexOf('translate')==-1){
							node.style.transform+=' translate('+dx+'px,'+dy+'px)';
						}
						else{
							node.style.transform='translate('+dx+'px,'+dy+'px)';
						}
					}
					ui.arena.appendChild(node);
					ui.refresh(node);
	
					for(var i=0;i<ui.thrown.length;i++){
						if(ui.thrown[i].parentNode!=ui.arena||
							ui.thrown[i].classList.contains('removing')){
							ui.thrown.splice(i--,1);
						}
					}
					ui.thrown.push(node);
					var uithrowns=ui.thrown.slice(0);
					var tops;
					switch(Math.floor((ui.thrown.length-1)/4)){
						case 0:
							tops=[0];
							break;
						case 1:
							tops=[-57,57];
							break;
						case 2:
							tops=[-114,0,114];
							break;
						default:
							tops=[-171,-57,57,171];
					}
					while(uithrowns.length){
						var throwns=uithrowns.splice(0,Math.min(uithrowns.length,4));
						switch(throwns.length){
							case 1:
								throwns[0]._transthrown='translate(0px,';
								break;
							case 2:
								throwns[0]._transthrown='translate(-57px,';
								throwns[1]._transthrown='translate(57px,';
								break;
							case 3:
								throwns[0]._transthrown='translate(-114px,';
								throwns[1]._transthrown='translate(0,';
								throwns[2]._transthrown='translate(114px,';
								break;
							case 4:
								throwns[0]._transthrown='translate(-171px,';
								throwns[1]._transthrown='translate(-57px,';
								throwns[2]._transthrown='translate(57px,';
								throwns[3]._transthrown='translate(171px,';
								break;
						}
						var top;
						if(tops.length){
							top=tops.shift();
						}
						else{
							top=0;
						}
						if(game.chess){
							top-=30;
						}
						for(var i=0;i<throwns.length;i++){
							throwns[i].style.transform=throwns[i]._transthrown+top+'px)';
							delete throwns[i]._transthrown;
						}
					}
	
					node.show();
					lib.listenEnd(node);
					return node;
				},
				$throwxy:function(card,left,top){
					var node=card.copy('thrown','thrownhighlight');
					node.dataset.position=this.dataset.position;
					node.hide();
					node.style.transitionProperty='left,top,opacity';
	
					ui.arena.appendChild(node);
					ui.refresh(node);
					node.show();
					node.style.left=left;
					node.style.top=top;
					lib.listenEnd(node);
					return node;
				},
				$throwxy2:function(card,left,top,trans,flipx,flipy){
					if(game.chess){
						return this.$throwxy.apply(this,arguments);
					}
					var node=card.copy('thrown','thrownhighlight');
					node.style.left=left;
					node.style.top=top;
					node.hide();
					// node.style.transitionProperty='left,top,opacity,transform';
	
					var parseCalc=function(str){
						var per=str.slice(str.indexOf('calc(')+5,str.indexOf('%'));
						var add=str.slice(str.indexOf('%')+1,str.indexOf('px')).replace(/\s/g,'');
						return [parseInt(per),parseInt(add)];
					}
					var nx=parseCalc(node.style.left);
					var ny=parseCalc(node.style.top);
					nx=nx[0]*ui.arena.offsetWidth/100+nx[1];
					ny=ny[0]*ui.arena.offsetHeight/100+ny[1];
					var dx=this.getLeft()+this.offsetWidth/2-52-nx;
					var dy=this.getTop()+this.offsetHeight/2-52-ny;
					if(flipx) dx=-dx;
					if(flipy) dy=-dy;
					if(trans){
						node.style.transform=trans+' translate('+dx+'px,'+dy+'px)';
					}
					else{
						node.style.transform='translate('+dx+'px,'+dy+'px)';
					}
	
					ui.arena.appendChild(node);
					ui.refresh(node);
					node.show();
					// node.style.transform=trans||'';
					lib.listenEnd(node);
					return node;
				},
				throwDice:function(num){
					if(typeof num!='number'){
						num=get.rand(6)+1;
						_status.event.num=num;
					}
					if(!game.online){
						game.pause();
					}
					game.broadcastAll(function(num){
						var diceContainer=ui.create.div('.fullsize.dice-container',ui.window);
						ui.window.classList.add('dicepaused');
						var dice=ui.create.div('.dice');
						var side;
	
						side=ui.create.div('.side.front',dice);
						ui.create.div('.dot.center',side);
						ui.create.div('.side.front.inner',dice);
	
						side=ui.create.div('.side.top',dice);
						ui.create.div('.dot.dtop.dleft',side);
						ui.create.div('.dot.dbottom.dright',side);
						ui.create.div('.side.top.inner',dice);
	
						side=ui.create.div('.side.right',dice);
						ui.create.div('.dot.dtop.dleft',side);
						ui.create.div('.dot.center',side);
						ui.create.div('.dot.dbottom.dright',side);
						ui.create.div('.side.right.inner',dice);
	
						side=ui.create.div('.side.left',dice);
						ui.create.div('.dot.dtop.dleft',side);
						ui.create.div('.dot.dtop.dright',side);
						ui.create.div('.dot.dbottom.dleft',side);
						ui.create.div('.dot.dbottom.dright',side);
						ui.create.div('.side.left.inner',dice);
	
						side=ui.create.div('.side.bottom',dice);
						ui.create.div('.dot.center',side);
						ui.create.div('.dot.dtop.dleft',side);
						ui.create.div('.dot.dtop.dright',side);
						ui.create.div('.dot.dbottom.dleft',side);
						ui.create.div('.dot.dbottom.dright',side);
						ui.create.div('.side.bottom.inner',dice);
	
						side=ui.create.div('.side.back',dice);
						ui.create.div('.dot.dtop.dleft',side);
						ui.create.div('.dot.dtop.dright',side);
						ui.create.div('.dot.dbottom.dleft',side);
						ui.create.div('.dot.dbottom.dright',side);
						ui.create.div('.dot.center dleft',side);
						ui.create.div('.dot.center dright',side);
						ui.create.div('.side.back.inner',dice);
	
						ui.create.div('.side.cover.x',dice);
						ui.create.div('.side.cover.y',dice);
						ui.create.div('.side.cover.z',dice);
	
						var map={
							1:[75,0,45],
							2:[-15,45,0],
							3:[165,-45,90],
							4:[345,-45,90],
							5:[345,-45,180],
							6:[255,0,135]
						};
						dice.roll=function(deg){
							if(typeof deg=='number'){
								dice.current[0]+=deg;
								deg=dice.current;
							}
							deg=deg.slice(0);
							dice.current=deg;
							this.style.transform='rotateX('+deg[0]+'deg) rotateY('+deg[1]+'deg) rotateZ('+deg[2]+'deg)';
						};
						dice.roll(map[num]);
						diceContainer.appendChild(dice);
						ui.refresh(dice);
						dice.roll(1025);
	
						dice.addEventListener('webkitTransitionEnd',function(){
							if(!dice.over){
								dice.style.transition='transform 0.8s ease';
								dice.roll(-20);
								dice.over=true;
							}
							else if(!dice.resumed){
								setTimeout(function(){
									diceContainer.delete();
									ui.window.classList.remove('dicepaused');
								},300);
								if(!game.online){
									setTimeout(game.resume,800);
								}
								dice.resumed=true;
							}
						});
					},num);
				},
				$giveAuto:function(card,player){
					if(Array.isArray(card)&&card.length==0) return;
					var args=Array.from(arguments);
					if(_status.connectMode||(!this.isUnderControl(true)&&!player.isUnderControl(true))){
						if(Array.isArray(card)){
							card=card.length;
						}
						else{
							card=1;
						}
						args[0]=card;
					}
					return this.$give.apply(this,args);
				},
				$give:function(card,player,log,init){
					if(init!==false){
						game.broadcast(function(source,card,player,init){
							source.$give(card,player,false,init);
						},this,card,player,init);
						if(typeof card=='number'&&card>=0){
							game.addVideo('give',this,[card,player.dataset.position]);
						}
						else{
							if(get.itemtype(card)=='card'){
								card=[card];
							}
							if(get.itemtype(card)=='cards'){
								game.addVideo('giveCard',this,[get.cardsInfo(card),player.dataset.position]);
							}
						}
					}
					if(get.itemtype(card)=='cards'){
						if(log!=false&&!_status.video){
							game.log(player,'从',this,'获得了',card);
						}
						if(this.$givemod){
							this.$givemod(card,player);
						}
						else{
							for(var i=0;i<card.length;i++){
								this.$give(card[i],player,false,false);
							}
						}
					}
					else if(typeof card=='number'&&card>=0){
						if(log!=false&&!_status.video){
							game.log(player,'从',this,'获得了'+get.cnNumber(card)+'张牌');
						}
						if(this.$givemod){
							this.$givemod(card,player);
						}
						else{
							while(card--) this.$give('',player,false,false);
						}
					}
					else{
						if(log!=false&&!_status.video){
							if(get.itemtype(card)=='card'&&log!=false){
								game.log(player,'从',this,'获得了',card);
							}
							else{
								game.log(player,'从',this,'获得了一张牌');
							}
						}
						if(this.$givemod){
							this.$givemod(card,player);
						}
						else{
							var node;
							if(get.itemtype(card)=='card'){
								node=card.copy('card','thrown',false);
							}
							else{
								node=ui.create.div('.card.thrown');
							}
							// node.dataset.position=this.dataset.position;
							node.fixed=true;
							this.$throwordered(node);
							// lib.listenEnd(node);
							// node.hide();
							// node.style.transitionProperty='left,top,opacity';
							//
							// node.style.transform='rotate('+(Math.random()*16-8)+'deg)';
							//
							// ui.arena.appendChild(node);
							// ui.refresh(node);
							// node.show();
							// node.style.left='calc(50% - 52px '+((Math.random()-0.5<0)?'+':'-')+' '+Math.random()*100+'px)';
							// node.style.top='calc(50% - 52px '+((Math.random()-0.5<0)?'+':'-')+' '+Math.random()*80+'px)';
	
							node.listenTransition(function(){
								var dx=player.getLeft()+player.offsetWidth/2-52-node.offsetLeft;
								var dy=player.getTop()+player.offsetHeight/2-52-node.offsetTop;
								if(node.style.transform&&node.style.transform!='none'&&node.style.transform.indexOf('translate')==-1){
									node.style.transform+=' translate('+dx+'px,'+dy+'px)';
								}
								else{
									node.style.transform='translate('+dx+'px,'+dy+'px)';
								}
	
								node.delete();
							});
							// setTimeout(function(){
							// 	// node.removeAttribute('style');
							// 	// node.dataset.position=player.dataset.position;
							// 	var dx=player.offsetLeft+player.offsetWidth/2-52-node.offsetLeft;
							// 	var dy=player.offsetTop+player.offsetHeight/2-52-node.offsetTop;
							// 	if(node.style.transform&&node.style.transform!='none'&&node.style.transform.indexOf('translate')==-1){
							// 		node.style.transform+=' translate('+dx+'px,'+dy+'px)';
							// 	}
							// 	else{
							// 		node.style.transform='translate('+dx+'px,'+dy+'px)';
							// 	}
							//
							// 	node.delete();
							// },700);
						}
					}
				},
				$equip:function(card){
					if(this.storage.disableEquip!=undefined&&this.storage.disableEquip.contains(get.subtype(card))){
						this.gain(card,'gain2');
						game.log(this,'装备失败');
					}
					else{
						game.broadcast(function(player,card){
							player.$equip(card);
						},this,card);
						card.fix();
						card.style.transform='';
						card.classList.remove('drawinghidden');
						delete card._transform;
						var player=this;
						var equipNum=get.equipNum(card);
						var equipped=false;
						for(var i=0;i<player.node.equips.childNodes.length;i++){
							if(get.equipNum(player.node.equips.childNodes[i])>=equipNum){
								player.node.equips.insertBefore(card,player.node.equips.childNodes[i]);
								equipped=true;
								break;
							}
						}
						if(!equipped){
							player.node.equips.appendChild(card);
							if(_status.discarded){
								_status.discarded.remove(card);
							}
						}
						var info=get.info(card);
						if(info.skills){
							for(var i=0;i<info.skills.length;i++){
								player.addSkillTrigger(info.skills[i]);
							}
						}
						return player;
					};
				},
				$gain:function(card,log,init){
					if(init!==false){
						game.broadcast(function(player,card,init){
							player.$gain(card,false,init);
						},this,card,init);
						if(typeof card=='number'&&card>=0){
							game.addVideo('gain',this,card);
						}
						else{
							if(get.itemtype(card)=='card'){
								card=[card];
							}
							if(get.itemtype(card)=='cards'){
								game.addVideo('gainCard',this,get.cardsInfo(card));
							}
							else{
								game.addVideo('gain',this,1);
							}
						}
					}
					if(get.itemtype(card)=='cards'){
						if(log!=false&&!_status.video){
							game.log(this,'获得了',card);
						}
						if(this.$gainmod){
							this.$gainmod(card);
						}
						else{
							for(var i=0;i<card.length;i++){
								this.$gain(card[i],false,false);
							}
						}
					}
					else if(typeof card=='number'&&card>1){
						if(log!=false&&!_status.video){
							game.log(this,'获得了'+get.cnNumber(card)+'张牌');
						}
						if(this.$gainmod){
							this.$gainmod(card);
						}
						else{
							for(var i=0;i<card;i++){
								this.$gain(1,false,false);
							}
						}
					}
					else{
						if(get.itemtype(card)=='card'&&log!=false&&!_status.video){
							game.log(this,'获得了',card);
						}
						if(this.$gainmod){
							this.$gainmod(card);
						}
						else{
							var node;
							if(get.itemtype(card)=='card'){
								// node=this.$throwordered(card.copy(),true);
								node=card.copy('thrown',false);
							}
							else{
								// node=this.$throwordered(ui.create.div('.card.thrown'),true);
								node=ui.create.div('.card.thrown');
								node.moveTo=lib.element.card.moveTo;
								node.moveDelete=lib.element.card.moveDelete;
							}
							node.fixed=true;
							node.style.left='calc(50% - 52px '+((Math.random()-0.5<0)?'+':'-')+' '+Math.random()*100+'px)';
							node.style.top='calc(50% - 52px '+((Math.random()-0.5<0)?'+':'-')+' '+Math.random()*100+'px)';
							node.style.transform='scale(0)';
							node.hide();
							ui.arena.appendChild(node);
							ui.refresh(node);
							node.show();
							node.style.transform='';
	
							lib.listenEnd(node);
							var player=this;
							setTimeout(function(){
								node.moveDelete(player);
							},700);
						}
					}
				},
				$gain2:function(cards,log){
					if(log===true){
						game.log(this,'获得了',cards);
					}
					game.broadcast(function(player,cards){
						player.$gain2(cards);
					},this,cards);
					if(get.itemtype(cards)=='card') cards=[cards];
					else if(get.itemtype(cards)!='cards') return;
					var list=any[];list2=[];
					for(var i=0;i<cards.length;i++){
						if(cards[i].clone&&
							(cards[i].clone.parentNode==this.parentNode||
							cards[i].clone.parentNode==ui.arena)&&
							parseFloat(getComputedStyle(cards[i].clone).opacity)>0.3){
							cards[i].clone.moveDelete(this);
							list2.push(cards[i].clone);
						}
						else{
							list.push(cards[i]);
						}
					}
					if(list2.length){
						game.addVideo('gain2',this,get.cardsInfo(list2));
					}
					if(list.length){
						this.$draw(list,'nobroadcast');
						return true;
					}
				},
				$skill:function(name,type,color,avatar){
					if(typeof type!='string') type='legend';
					if(!avatar){
						this.playerfocus(1500);
						game.delay(2);
					}
					else{
						game.addVideo('playerfocus2');
						game.broadcastAll(function(){
							ui.arena.classList.add('playerfocus');
							setTimeout(function(){
								ui.arena.classList.remove('playerfocus');
							},1800)
						});
						game.delay(3);
					}
					var that=this;
					setTimeout(function(){
						game.broadcastAll(function(that,type,name,color,avatar){
							if(lib.config.animation&&!lib.config.low_performance){
								if(game.chess){
									that['$'+type+'2'](1200);
								}
								else{
									that['$'+type](1200);
								}
							}
							if(name){
								that.$fullscreenpop(name,color,avatar);
							}
						},that,type,name,color,avatar);
					},avatar?0:300);
				},
				$fire:function(){
					game.addVideo('flame',this,'fire');
					var left,top;
					if(game.chess){
						var rect=this.getBoundingClientRect();
						left=rect.left;
						top=rect.top;
					}
					else{
						left=this.getLeft();
						top=this.getTop();
					}
					game.animate.flame(left+this.offsetWidth/2,
						top+this.offsetHeight-20,700,'fire');
				},
				$thunder:function(){
					game.addVideo('flame',this,'thunder');
					var left,top;
					if(game.chess){
						var rect=this.getBoundingClientRect();
						left=rect.left;
						top=rect.top;
					}
					else{
						left=this.getLeft();
						top=this.getTop();
					}
					game.animate.flame(left+this.offsetWidth/2,
						top+this.offsetHeight-30,700,'thunder');
				},
				$rare2:function(){
					game.addVideo('flame',this,'rare2');
					var rect=this.getBoundingClientRect();
					var left=rect.left;
					var top=rect.top+15;
					game.animate.flame(left+this.offsetWidth/2,
						top+this.offsetHeight-30,700,'rare');
				},
				$epic2:function(){
					game.addVideo('flame',this,'epic2');
					var rect=this.getBoundingClientRect();
					var left=rect.left;
					var top=rect.top+15;
					game.animate.flame(left+this.offsetWidth/2,
						top+this.offsetHeight-30,700,'epic');
				},
				$legend2:function(){
					game.addVideo('flame',this,'legend2');
					var rect=this.getBoundingClientRect();
					var left=rect.left;
					var top=rect.top+15;
					game.animate.flame(left+this.offsetWidth/2,
						top+this.offsetHeight-30,700,'legend');
				},
				$rare:function(time){
					time=time||700;
					game.addVideo('flame',this,'rare');
					var left,top;
					if(game.chess){
						left=this.getLeft()-ui.arena.offsetLeft;
						top=this.getTop()-ui.arena.offsetTop;
					}
					else{
						left=this.getLeft();
						top=this.getTop();
					}
					if(this.classList.contains('minskin')){
						top+=15;
					}
					game.animate.flame(left+this.offsetWidth/2,
						top+this.offsetHeight-30,time,'rare');
				},
				$epic:function(time){
					time=time||700;
					game.addVideo('flame',this,'epic');
					var left,top;
					if(game.chess){
						left=this.getLeft()-ui.arena.offsetLeft;
						top=this.getTop()-ui.arena.offsetTop;
					}
					else{
						left=this.getLeft();
						top=this.getTop();
					}
					if(this.classList.contains('minskin')){
						top+=15;
					}
					game.animate.flame(left+this.offsetWidth/2,
						top+this.offsetHeight-30,time,'epic');
				},
				$legend:function(time){
					time=time||700;
					game.addVideo('flame',this,'legend');
					var left,top;
					if(game.chess){
						left=this.getLeft()-ui.arena.offsetLeft;
						top=this.getTop()-ui.arena.offsetTop;
					}
					else{
						left=this.getLeft();
						top=this.getTop();
					}
					if(this.classList.contains('minskin')){
						top+=15;
					}
					game.animate.flame(left+this.offsetWidth/2,
						top+this.offsetHeight-30,time,'legend');
				},
				$coin:function(){
					game.broadcast(function(player){
						if(!lib.config.low_performance){
							player.$coin();
						}
					},this);
					game.addVideo('flame',this,'coin');
					var left=this.getLeft()-ui.arena.offsetLeft;
					var top=this.getTop()-ui.arena.offsetTop;
					if(this.classList.contains('minskin')){
						top+=15;
					}
					top-=25;
					game.animate.flame(left+this.offsetWidth/2,
						top+this.offsetHeight-30,700,'coin');
				},
				$dust:function(){
					game.broadcast(function(player){
						if(!lib.config.low_performance){
							player.$dust();
						}
					},this);
					game.addVideo('flame',this,'dust');
					var left=this.getLeft()-ui.arena.offsetLeft;
					var top=this.getTop()-ui.arena.offsetTop;
					if(this.classList.contains('minskin')){
						top+=15;
					}
					top-=25;
					game.animate.flame(left+this.offsetWidth/2,
						top+this.offsetHeight-30,700,'dust');
				},
				$recover:function(){
					game.addVideo('flame',this,'recover');
					var left,top;
					if(game.chess){
						var rect=this.getBoundingClientRect();
						left=rect.left;
						top=rect.top;
					}
					else{
						left=this.getLeft();
						top=this.getTop();
					}
					game.animate.flame(left+this.offsetWidth/2,
						top+this.offsetHeight-30,700,'recover');
				},
				$fullscreenpop:function(str,nature,avatar){
					game.broadcast(function(player,str,nature,avatar){
						player.$fullscreenpop(str,nature,avatar);
					},this,str,nature,avatar);
					game.addVideo('fullscreenpop',this,[str,nature,avatar]);
					var node=ui.create.div('.damage');
					if(avatar&&this.node){
						if(avatar=='vice'){
							if(lib.character[this.name2]){
								avatar=this.node.avatar2;
							}
						}
						else{
							if(lib.character[this.name]){
								avatar=this.node.avatar;
							}
						}
						if(!get.is.div(avatar)){
							avatar=false;
						}
					}
					else{
						avatar=false;
					}
					if(avatar){
						node.classList.add('fullscreenavatar');
						ui.create.div('',ui.create.div(node));
						// ui.create.div('',str.split('').join('<br>'),ui.create.div('.text.textbg',node));
						ui.create.div('','<div>'+str.split('').join('</div><br><div>')+'</div>',ui.create.div('.text',node));
						node.firstChild.firstChild.style.backgroundImage=avatar.style.backgroundImage;
						node.dataset.nature=nature||'unknown';
						var num=0;
						var nodes=node.lastChild.firstChild.querySelectorAll('div');
						var interval=setInterval(function(){
							if(num<nodes.length){
								nodes[num].classList.add('flashtext');
								num++;
							}
							else{
								clearInterval(interval);
							}
						},100);
					}
					else{
						avatar=false;
						node.innerHTML=str;
						node.dataset.nature=nature||'soil';
					}
					if(avatar){
						var rect1=ui.window.getBoundingClientRect();
						var rect2=this.getBoundingClientRect();
						var dx=Math.round(2*rect2.left+rect2.width-rect1.width);
						var dy=Math.round(2*rect2.top+rect2.height-rect1.height);
						node.style.transform='scale(0.5) translate('+dx+'px,'+dy+'px)';
					}
					ui.window.appendChild(node);
					ui.refresh(node);
					if(avatar){
						node.style.transform='scale(1)';
						node.style.opacity=1;
					}
					else{
						node.classList.add('damageadded');
					}
					setTimeout(function(){
						node.delete();
						node.style.transform='scale(1.5)'
					},avatar?1600:1000);
				},
				$damagepop:function(num,nature,font){
					if(typeof num=='number'||typeof num=='string'){
						game.addVideo('damagepop',this,[num,nature,font]);
						game.broadcast(function(player,num,nature,font){
							player.$damagepop(num,nature,font);
						},this,num,nature,font);
						var node=ui.create.div('.damage');
						if(font){
							node.classList.add('normal-font');
						}
						if(typeof num=='number'&&num>0){
							num='+'+num;
						}
						node.innerHTML=num;
						this.damagepopups.push(node);
						node.dataset.nature=nature||'soil';
						if(this.damagepopups.length==1){
							this.$damagepop();
						}
					}
					else if(this.damagepopups.length){
						var node=this.damagepopups[0];
						this.appendChild(node);
						ui.refresh(node);
						node.classList.add('damageadded');
						node.listenTransition(function(){
							setTimeout(function(){
								node.delete();
							},200);
						});
						// setTimeout(function(){
						// 	node.delete();
						// },500);
						var that=this;
						setTimeout(function(){
							that.damagepopups.shift();
							that.$damagepop();
						},500);
					}
				},
				$damage:function(source){
					if(get.itemtype(source)=='player'){
						game.addVideo('damage',this,source.dataset.position);
					}
					else{
						game.addVideo('damage',this);
					}
					game.broadcast(function(player,source){
						player.$damage(source);
					},this,source);
					if(source&&source!=this&&lib.config.damage_shake){
						var left,top;
						if(source.getTop()==this.getTop()){
							left=20;
							top=0;
						}
						else{
							var ratio=(source.getLeft()-this.getLeft())/(source.getTop()-this.getTop());
							left=Math.abs(20*ratio/Math.sqrt(1+ratio*ratio));
							top=Math.abs(20/Math.sqrt(1+ratio*ratio));
						}
						if(source.getLeft()-this.getLeft()>0) left=-left;
						if(source.getTop()-this.getTop()>0) top=-top;
						if(get.is.mobileMe(this)){
							if(this.classList.contains('linked')){
								this.node.avatar.style.transform='translate('+left+'px,'+top+'px) rotate(-90deg)';
								this.node.avatar2.style.transform='translate('+left+'px,'+top+'px) rotate(-90deg)';
							}
							else{
								this.node.avatar.style.transform='translate('+left+'px,'+top+'px)';
								this.node.avatar2.style.transform='translate('+left+'px,'+top+'px)';
							}
						}
						else if(this.classList.contains('linked')&&get.is.newLayout()){
							this.style.transform='translate('+left+'px,'+top+'px) rotate(-90deg)';
						}
						else if(this._chesstransform){
							this.style.transform='translate('+(left+this._chesstransform[0])+'px,'+(top+this._chesstransform[1])+'px)';
						}
						else{
							this.style.transform='translate('+left+'px,'+top+'px)';
						}
					}
					else{
						var zoom1=0.9,zoom2=0.95;
						if(arguments[1]=='phase'){
							zoom1=1.05;
							zoom2=1.05;
						}
						if(get.is.mobileMe(this)){
							if(this.classList.contains('linked')){
								this.node.avatar.style.transform='scale('+zoom1+') rotate(-90deg)';
								this.node.avatar2.style.transform='scale('+zoom1+') rotate(-90deg)';
							}
							else{
								this.node.avatar.style.transform='scale('+zoom1+')';
								this.node.avatar2.style.transform='scale('+zoom1+')';
							}
						}
						else if(this.classList.contains('linked')&&get.is.newLayout()){
							this.style.transform='scale('+zoom2+') rotate(-90deg)';
						}
						else if(game.chess&&this._chesstransform){
							this.style.transform='translate('+this._chesstransform[0]+'px,'+this._chesstransform[1]+'px) scale('+zoom2+')';
						}
						else{
							this.style.transform='scale('+zoom2+')';
						}
					}
					this.queue();
				},
				$die:function(){
					game.addVideo('die',this);
					game.broadcast(function(player){
						player.$die();
					},this);
					if(lib.config.die_move!='off'){
						this.$dieflip(lib.config.die_move);
					}
					if(lib.element.player.$dieAfter){
						lib.element.player.$dieAfter.call(this);
					}
				},
				$dieflip:function(type){
					var top0=ui.window.offsetHeight/2;
					var left0=ui.window.offsetWidth/2;
					var ratio=(left0-this.getLeft())/(top0-this.getTop());
					var left=Math.abs(50*ratio/Math.sqrt(1+ratio*ratio));
					var top=Math.abs(50/Math.sqrt(1+ratio*ratio));
					if(left0-this.getLeft()>0) left=-left;
					if(top0-this.getTop()>0) top=-top;
					if(get.is.mobileMe(this)){
						left=-Math.random()*5-10;
						top=Math.random()*5+10;
					}
					if(this._chesstransform){
						left+=this._chesstransform[0];
						top+=this._chesstransform[1];
					}
					var transform='translate('+left+'px,'+top+'px) '+
					'rotate('+(Math.random()*20-10)+'deg) ';
					if(type=='flip'){
						if(game.layout=='long'||game.layout=='long2'){
							transform+='rotateY(180deg)';
						}
						else{
							transform+=((Math.random()-0.5<0)?'rotateX(180deg)':'rotateY(180deg)');
						}
					}
					if(get.is.mobileMe(this)){
						this.node.avatar.style.transform=transform;
						this.node.avatar2.style.transform=transform;
						this.style.transform='';
					}
					else{
						this.node.avatar.style.transform='';
						this.node.avatar2.style.transform='';
						this.style.transform=transform;
					}
					this.queue(false);
				},
				$phaseJudge:function(card){
					game.addVideo('phaseJudge',this,get.cardInfo(card));
					var player=this;
					var clone=player.$throw(card);
					if(lib.config.low_performance&&card&&card.clone){
						var waitingForTransition=get.time();
						_status.waitingForTransition=waitingForTransition;
						card.clone.listenTransition(function(){
							if(_status.waitingForTransition==waitingForTransition&&_status.paused){
								game.resume();
							}
						});
						game.pause();
					}
					else{
						game.delay();
					}
				}
			},
			card:{
				init:function(card){
					if(Array.isArray(card)){
						if(card[2]=='huosha'){
							card[2]='sha';
							card[3]='fire';
						}
						if(card[2]=='leisha'){
							card[2]='sha';
							card[3]='thunder';
						}
					}
					else if(typeof card=='object'){
						card=[card.suit,card.number,card.name,card.nature];
					}
					var cardnum=card[1]||'';
					if([1,11,12,13].contains(cardnum)){
					cardnum={'1':'A','11':'J','12':'Q','13':'K'}[cardnum]
					}
					if(!lib.card[card[2]]){
						lib.card[card[2]]={};
					}
					var info=lib.card[card[2]];
					if(info.global&&!this.classList.contains('button')){
						if(Array.isArray(info.global)){
							while(info.global.length){
								game.addGlobalSkill(info.global.shift());
							}
						}
						else if(typeof info.global=='string'){
							game.addGlobalSkill(info.global);
						}
						delete info.global;
					}
					if(this.name){
						this.classList.remove('epic');
						this.classList.remove('legend');
						this.classList.remove('gold');
						this.classList.remove('unique');
						this.style.background='';
						var subtype=get.subtype(this);
						if(subtype){
							this.classList.remove(subtype);
						}
					}
					if(info.epic){
						this.classList.add('epic');
					}
					else if(info.legend){
						this.classList.add('legend');
					}
					else if(info.gold){
						this.classList.add('gold');
					}
					else if(info.unique){
						this.classList.add('unique');
					}
					var bg=card[2];
					if(info.cardimage){
						bg=info.cardimage;
					}
					var img=lib.card[bg].image;
					if(img){
						if(img.indexOf('db:')==0){
							img=img.slice(3);
						}
						else if(img.indexOf('ext:')!=0){
							img=null;
						}
					}
					this.classList.remove('fullskin');
					this.classList.remove('fullimage');
					this.classList.remove('fullborder');
					this.dataset.cardName=card[2];
					this.dataset.cardType=info.type||'';
					this.dataset.cardSubype=info.subtype||'';
					this.dataset.cardMultitarget=info.multitarget?'1':'0';
					this.node.name.dataset.nature='';
					this.node.info.classList.remove('red');
					if(!lib.config.hide_card_image&&lib.card[bg].fullskin){
						this.classList.add('fullskin');
						if(img){
							if(img.indexOf('ext:')==0){
								this.node.image.setBackgroundImage(img.replace(/ext:/,'extension/'));
							}
							else{
								this.node.image.setBackgroundDB(img);
							}
						}
						else{
							if(lib.card[bg].modeimage){
								this.node.image.setBackgroundImage('image/mode/'+lib.card[bg].modeimage+'/card/'+bg+'.png');
							}
							else{
								this.node.image.setBackgroundImage('image/card/'+bg+'.png');
							}
						}
					}
					else if(lib.card[bg].image=='background'){
						if(card[3]) this.node.background.setBackground(bg+'_'+card[3],'card');
						else this.node.background.setBackground(bg,'card');
					}
					else if(lib.card[bg].fullimage){
						this.classList.add('fullimage');
						if(img){
							if(img.indexOf('ext:')==0){
								this.setBackgroundImage(img.replace(/ext:/,'extension/'));
								this.style.backgroundSize='cover';
							}
							else{
								this.setBackgroundDB(img);
							}
						}
						else if(lib.card[bg].image){
							if(lib.card[bg].image.indexOf('character:')==0){
								this.setBackground(lib.card[bg].image.slice(10),'character');
							}
							else{
								this.setBackground(lib.card[bg].image);
							}
						}
						else{
							var cardPack=lib.cardPack['mode_'+get.mode()];
							if(Array.isArray(cardPack)&&cardPack.contains(bg)){
								this.setBackground('mode/'+get.mode()+'/card/'+bg);
							}
							else{
								this.setBackground('card/'+bg);
							}
						}
					}
					else if(lib.card[bg].fullborder){
						this.classList.add('fullborder');
						if(lib.card[bg].fullborder=='gold'){
							this.node.name.dataset.nature='metalmm';
						}
						else if(lib.card[bg].fullborder=='silver'){
							this.node.name.dataset.nature='watermm';
						}
						if(!this.node.avatar){
							this.node.avatar=ui.create.div('.cardavatar');
							this.insertBefore(this.node.avatar,this.firstChild);
						}
						if(!this.node.framebg){
							this.node.framebg=ui.create.div('.cardframebg');
							this.node.framebg.dataset.auto=lib.card[bg].fullborder;
							this.insertBefore(this.node.framebg,this.firstChild);
						}
						if(img){
							if(img.indexOf('ext:')==0){
								this.node.avatar.setBackgroundImage(img.replace(/ext:/,'extension/'));
								this.node.avatar.style.backgroundSize='cover';
							}
							else{
								this.node.avatar.setBackgroundDB(img);
							}
						}
						else if(lib.card[bg].image){
							if(lib.card[bg].image.indexOf('character:')==0){
								this.node.avatar.setBackground(lib.card[bg].image.slice(10),'character');
							}
							else{
								this.node.avatar.setBackground(lib.card[bg].image);
							}
						}
						else{
							var cardPack=lib.cardPack['mode_'+get.mode()];
							if(Array.isArray(cardPack)&&cardPack.contains(bg)){
								this.node.avatar.setBackground('mode/'+get.mode()+'/card/'+bg);
							}
							else{
								this.node.avatar.setBackground('card/'+bg);
							}
						}
					}
					else if(lib.card[bg].image=='card'){
						if(card[3]) this.setBackground(bg+'_'+card[3],'card');
						else this.setBackground(bg,'card');
					}
					else if(typeof lib.card[bg].image=='string'&&!lib.card[bg].fullskin){
						if(img){
							if(img.indexOf('ext:')==0){
								this.setBackgroundImage(img.replace(/ext:/,'extension/'));
								this.style.backgroundSize='cover';
							}
							else{
								this.setBackgroundDB(img);
							}
						}
						else{
							this.setBackground(lib.card[bg].image);
						}
					}
					else{
						this.node.background.innerHTML=lib.translate[bg+'_cbg']||lib.translate[bg+'_bg']||get.translation(bg)[0];
						// this.node.background.style.fontFamily=lib.config.card_font;
						if(this.node.background.innerHTML.length>1) this.node.background.classList.add('tight');
						else this.node.background.classList.remove('tight');
					}
					if(!lib.card[bg].fullborder&&this.node.avatar&&this.node.framebg){
						this.node.avatar.remove();
						this.node.framebg.remove();
						delete this.node.avatar;
						delete this.node.framebg;
					}
					if(info.noname&&!this.classList.contains('button')){
						this.node.name.style.display='none';
					}
					if(info.color){
						this.style.color=info.color;
					}
					if(info.textShadow){
						this.style.textShadow=info.textShadow;
					}
					if(info.opacity){
						this.node.info.style.opacity=info.opacity;
						this.node.name.style.opacity=info.opacity;
					}
					if(info.modinfo){
						this.node.info.innerHTML=info.modinfo;
					}
					else{
						this.node.info.innerHTML=get.translation(card[0])+'<span> </span>'+cardnum;
					}
					if(info.addinfo){
						if(!this.node.addinfo){
							this.node.addinfo=ui.create.div('.range',this);
						}
						this.node.addinfo.innerHTML=info.addinfo;
					}
					else if(this.node.addinfo){
						this.node.addinfo.remove();
						delete this.node.addinfo;
					}
					if(card[0]=='heart'||card[0]=='diamond'){
						this.node.info.classList.add('red');
					}
					this.node.name.innerHTML='';
					this.node.image.className='image';
					var name=get.translation(card[2]);
					if(card[2]=='sha'){
						if(card[3]=='fire'){
							name='火'+name;
							this.node.image.classList.add('fire');
						}
						else if(card[3]=='thunder'){
							name='雷'+name;
							this.node.image.classList.add('thunder');
						}
					}
					for(var i=0;i<name.length;i++){
						this.node.name.innerHTML+=name[i]+'<br/>';
					}
					if(name.length>=5){
						this.node.name.classList.add('long');
						if(name.length>=7){
							this.node.name.classList.add('longlong');
						}
					}
					this.node.name2.innerHTML=get.translation(card[0])+cardnum+' '+name;
					this.suit=card[0];
					this.number=parseInt(card[1])||0;
					this.name=card[2];
					this.classList.add('card');
					if(card[3]){
						if(lib.nature.contains(card[3])) this.nature=card[3];
						this.classList.add(card[3]);
					}
					else if(this.nature){
						this.classList.remove(this.nature);
						delete this.nature;
					}
					if(info.subtype) this.classList.add(info.subtype);
					if(this.inits){
						for(var i=0;i<lib.element.card.inits.length;i++){
							lib.element.card.inits[i](this);
						}
					}
					if(typeof info.init=='function') info.init();
					this.node.range.innerHTML='';
					switch(get.subtype(this)){
						case 'equip1':
							var added=false;
							if(lib.card[this.name]&&lib.card[this.name].distance){
								var dist=lib.card[this.name].distance;
								if(dist.attackFrom){
									added=true;
									this.node.range.innerHTML='范围: '+(-dist.attackFrom+1);
								}
							}
							if(!added){
								this.node.range.innerHTML='范围: 1';
							}
							break;
						case 'equip3':
						if(info.distance&&info.distance.globalTo){
							this.node.range.innerHTML='防御: '+info.distance.globalTo;
							this.node.name2.innerHTML+='+';
						}
						break;
						case 'equip4':
						if(info.distance&&info.distance.globalFrom){
							this.node.range.innerHTML='进攻: '+(-info.distance.globalFrom);
							this.node.name2.innerHTML+='-';
						}
						break;
					}
					if(_status.connectMode&&!game.online&&lib.cardOL&&!this.cardid){
						this.cardid=get.id();
						lib.cardOL[this.cardid]=this;
					}
					if(!_status.connectMode&&!_status.video){
						this.cardid=get.id();
					}
					var tags=[];
					if(Array.isArray(card[4])){
						tags.addArray(card[4]);
					}
					if(this.cardid){
						if(!_status.cardtag){
							_status.cardtag={};
						}
						for(var i in _status.cardtag){
							if(_status.cardtag[i].contains(this.cardid)){
								tags.add(i);
							}
						}
						if(tags.length){
							var tagstr=' <span class="cardtag">';
							for(var i=0;i<tags.length;i++){
								var tag=tags[i];
								if(!_status.cardtag[tag]){
									_status.cardtag[tag]=[];
								}
								_status.cardtag[tag].add(this.cardid);
								tagstr+=lib.translate[tag+'_tag'];
							}
							tagstr+='</span>';
							this.node.range.innerHTML+=tagstr;
						}
					}
					return this;
				},
				updateTransform:function(bool,delay){
					if(delay){
						var that=this;
						setTimeout(function(){
							that.updateTransform(that.classList.contains('selected'));
						},delay);
					}
					else{
						if(_status.event.player!=game.me) return;
						if(this._transform&&this.parentNode&&this.parentNode.parentNode&&
							this.parentNode.parentNode.parentNode==ui.me&&
							(!_status.mousedown||_status.mouseleft)&&
							(!this.parentNode.parentNode.classList.contains('scrollh')||(game.layout=='long2'||game.layout=='nova'))){
							if(bool){
								this.style.transform=this._transform+' translateY(-20px)';
							}
							else{
								this.style.transform=this._transform||'';
							}
						}
					}
				},
				aiexclude:function(){
					_status.event._aiexclude.add(this);
				},
				getSource:function(name){
					if(this.name==name) return true;
					var info=lib.card[this.name];
					if(info&&Array.isArray(info.source)){
						return info.source.contains(name);
					}
					return false;
				},
				moveDelete:function(player){
					this.fixed=true;
					if(!this._listeningEnd||this._transitionEnded){
						this.moveTo(player);
						var that=this;
						setTimeout(function(){
							that.delete();
						},200);
					}
					else{
						this._onEndMoveDelete=player;
					}
				},
				moveTo:function(player){
					this.fixed=true;
					var dx,dy;
					if(this.classList.contains('center')){
						var nx=[50,-52];
						var ny=[50,-52];
						nx=nx[0]*ui.arena.offsetWidth/100+nx[1];
						ny=ny[0]*ui.arena.offsetHeight/100+ny[1];
						dx=player.getLeft()+player.offsetWidth/2-52-nx;
						dy=player.getTop()+player.offsetHeight/2-52-ny;
					}
					else{
						this.style.left=this.offsetLeft+'px';
						this.style.top=this.offsetTop+'px';
	
						dx=player.getLeft()+player.offsetWidth/2-52-this.offsetLeft;
						dy=player.getTop()+player.offsetHeight/2-52-this.offsetTop;
					}
					if(get.is.mobileMe(player)){
						dx+=get.cardOffset();
						if(ui.arena.classList.contains('oblongcard')){
							dy-=16;
						}
					}
	
	
					if(this.style.transform&&this.style.transform!='none'&&this.style.transform.indexOf('translate')==-1){
						this.style.transform+=' translate('+dx+'px,'+dy+'px)';
					}
					else{
						this.style.transform='translate('+dx+'px,'+dy+'px)';
					}
					return this;
				},
				copy:function(){
					var node=this.cloneNode(true);
					node.style.transform='';
					node.name=this.name;
					node.suit=this.suit;
					node.number=this.number;
					node.classList.remove('hidden');
					node.classList.remove('start');
					node.classList.remove('thrown');
					node.classList.remove('selectable');
					node.classList.remove('selected');
					node.classList.remove('removing');
					node.classList.remove('drawinghidden');
					node.node={
						name:node.querySelector('.name'),
						info:node.querySelector('.info'),
						intro:node.querySelector('.intro'),
						background:node.querySelector('.background'),
						image:node.querySelector('.image'),
					}
					var clone=true;
					var position;
					for(var i=0;i<arguments.length;i++){
						if(typeof arguments[i]=='string') node.classList.add(arguments[i]);
						else if(get.objtype(arguments[i])=='div') position=arguments[i];
						else if(typeof arguments[i]=='boolean') clone=arguments[i];
					}
					node.moveTo=lib.element.card.moveTo;
					node.moveDelete=lib.element.card.moveDelete;
					if(clone) this.clone=node;
					if(position) position.appendChild(node);
					return node;
				},
				uncheck:function(skill){
					if(skill) this._uncheck.add(skill);
					this.classList.add('uncheck');
				},
				recheck:function(skill){
					if(skill) this._uncheck.remove(skill);
					else this._uncheck.length=0;
					if(this._uncheck.length==0) this.classList.remove('uncheck');
				},
				discard:function(bool){
					if(!this.destroyed){
						ui.discardPile.appendChild(this);
					}
					this.fix();
					this.classList.remove('glow');
					if(bool===false){
						ui.cardPile.insertBefore(this,ui.cardPile.childNodes[Math.floor(Math.random()*ui.cardPile.childNodes.length)]);
					}
					else{
						if(_status.discarded){
							_status.discarded.add(this);
						}
					}
				},
				hasTag:function(tag){
					if(this.cardid&&_status.cardtag&&_status.cardtag[tag]&&_status.cardtag[tag].contains(this.cardid)){
						return true;
					}
					return false;
				},
				hasPosition:function(){
					return ['h','e','j'].contains(get.position(this));
				},
				isInPile:function(){
					return ['c','d'].contains(get.position(this));
				},
			},
			button:{
				exclude:function(){
					if(_status.event.excludeButton==undefined){
						_status.event.excludeButton=[];
					}
					_status.event.excludeButton.add(this);
				},
			},
			event:{
				finish:function(){
					this.finished=true;
				},
				cancel:function(){
					this.untrigger.call(this,arguments);
					this.finish();
					this.trigger(this.name+'Cancelled');
				},
				goto:function(step){
					this.step=step-1;
				},
				redo:function(){
					this.step--;
				},
				set:function(key,value){
					if(arguments.length==1&&Array.isArray(arguments[0])){
						for(var i=0;i<arguments[0].length;i++){
							if(Array.isArray(arguments[0][i])){
								this.set(arguments[0][i][0],arguments[0][i][1]);
							}
						}
					}
					else{
						if(typeof key!='string'){
							console.log('warning: using non-string object as event key');
							console.log(key,value);
							console.log(_status.event);
						}
						this[key]=value;
						this._set.push([key,value]);
					}
					return this;
				},
				setContent:function(name){
					if(typeof name=='function'){
						this.content=lib.init.parse(name);
					}
					else{
						if(!lib.element.content[name]._parsed){
							lib.element.content[name]=lib.init.parse(lib.element.content[name]);
							lib.element.content[name]._parsed=true;
						}
						this.content=lib.element.content[name];
					}
					return this;
				},
				getLogv:function(){
					for(var i=1;i<=3;i++){
						var event=this.getParent(i);
						if(event&&event.logvid) return event.logvid;
					}
					return null;
				},
				send:function(){
					this.player.send(function(name,args,set,event,skills){
						game.me.applySkills(skills);
						var next=game.me[name].apply(game.me,args);
						for(var i=0;i<set.length;i++){
							next.set(set[i][0],set[i][1]);
						}
						if(next._backupevent){
							next.backup(next._backupevent);
						}
						next._modparent=event;
						game.resume();
					},this.name,this._args||any[];this._set,
					get.stringifiedResult(this.parent,3),get.skillState(this.player));
					this.player.wait();
					game.pause();
				},
				resume:function(){
					delete this._cardChoice;
					delete this._targetChoice;
					delete this._skillChoice;
				},
				getParent:function(level,forced){
					var parent;
					if(this._modparent&&game.online){
						parent=this._modparent;
					}
					else{
						parent=this.parent;
					}
					var toreturn={};
					if(typeof level=='string'&&forced==true){
						toreturn=null;
					}
					if(!parent) return toreturn;
					if(typeof level=='number'){
						for(var i=1;i<level;i++){
							if(!parent) return toreturn;
							parent=parent.parent;
						}
					}
					else if(typeof level=='string'){
						for(var i=0;i<20;i++){
							if(!parent) return toreturn;
							if(parent.name==level) return parent;
							parent=parent.parent;
						}
						if(!parent) return toreturn;
					}
					if(toreturn===null){
						return null;
					}
					return parent;
				},
				getTrigger:function(){
					return this.getParent()._trigger;
				},
				getRand:function(){
					if(!this._rand) this._rand=Math.random();
					return this._rand;
				},
				insert:function(func,map){
					var next=game.createEvent(this.name+'Inserted',false,this);
					next.setContent(func);
					for(var i in map){
						next.set(i,map[i]);
					}
					return next;
				},
				insertAfter:function(func,map){
					var next=game.createEvent(this.name+'Inserted',false,{next:[]});
					this.after.push(next);
					next.setContent(func);
					for(var i in map){
						next.set(i,map[i]);
					}
					return next;
				},
				backup:function(skill){
					this._backup={
						filterButton:this.filterButton,
						selectButton:this.selectButton,
						filterTarget:this.filterTarget,
						selectTarget:this.selectTarget,
						filterCard:this.filterCard,
						selectCard:this.selectCard,
						position:this.position,
						forced:this.forced,
						fakeforce:this.fakeforce,
						_aiexclude:this._aiexclude,
						complexSelect:this.complexSelect,
						complexCard:this.complexCard,
						complexTarget:this.complexTarget,
						_cardChoice:this._cardChoice,
						_targetChoice:this._targetChoice,
						_skillChoice:this._skillChoice,
						ai1:this.ai1,
						ai2:this.ai2,
					}
					if(skill){
						var info=get.info(skill);
						this.skill=skill;
						this._aiexclude=[];
						if(info.viewAs){
							if(info.filterButton!=undefined) this.filterButton=get.filter(info.filterButton);
							if(info.selectButton!=undefined) this.selectButton=info.selectButton;
							if(info.filterTarget!=undefined) this.filterTarget=get.filter(info.filterTarget);
							if(info.selectTarget!=undefined) this.selectTarget=info.selectTarget;
							if(info.filterCard!=undefined){
								this.filterCard=function(card,player,event){
									if(!info.ignoreMod&&player){
										if(!event) event=_status.event;
										if(event.name=='chooseToUse'){
											var mod=game.checkMod(card,player,'unchanged','cardEnabled',player);
											if(mod!='unchanged') return mod;
										}
										if(event.name=='chooseToRespond'){
											var mod=game.checkMod(card,player,'unchanged','cardRespondable',player);
											if(mod!='unchanged') return mod;
										}
									}
									return get.filter(info.filterCard)(card,player,event);
								};
							}
							if(info.selectCard!=undefined) this.selectCard=info.selectCard;
							if(info.position!=undefined) this.position=info.position;
							if(info.forced!=undefined) this.forced=info.forced;
							if(info.complexSelect!=undefined) this.complexSelect=info.complexSelect;
							if(info.complexCard!=undefined) this.complexCard=info.complexCard;
							if(info.complexTarget!=undefined) this.complexTarget=info.complexTarget;
							if(info.ai1!=undefined) this.ai1=info.ai1;
							if(info.ai2!=undefined) this.ai2=info.ai2;
						}
						else{
							this.filterButton=info.filterButton?get.filter(info.filterButton):undefined;
							this.selectButton=info.selectButton;
							this.filterTarget=info.filterTarget?get.filter(info.filterTarget):undefined;
							this.selectTarget=info.selectTarget;
							this.filterCard=info.filterCard?get.filter(info.filterCard):undefined;
							this.selectCard=info.selectCard;
							this.position=info.position;
							this.forced=info.forced;
							this.complexSelect=info.complexSelect;
							this.complexCard=info.complexCard;
							this.complexTarget=info.complexTarget;
							if(info.ai1!=undefined) this.ai1=info.ai1;
							if(info.ai2!=undefined) this.ai2=info.ai2;
						}
						delete this.fakeforce;
					}
					delete this._cardChoice;
					delete this._targetChoice;
					delete this._skillChoice;
				},
				restore:function(){
					if(this._backup){
						this.filterButton=this._backup.filterButton;
						this.selectButton=this._backup.selectButton;
						this.filterTarget=this._backup.filterTarget;
						this.selectTarget=this._backup.selectTarget;
						this.filterCard=this._backup.filterCard;
						this.selectCard=this._backup.selectCard;
						this.position=this._backup.position;
						this.forced=this._backup.forced;
						this.fakeforce=this._backup.fakeforce;
						this._aiexclude=this._backup._aiexclude;
						this.complexSelect=this._backup.complexSelect;
						this.complexCard=this._backup.complexCard;
						this.complexTarget=this._backup.complexTarget;
						this.ai1=this._backup.ai1;
						this.ai2=this._backup.ai2;
						this._cardChoice=this._backup._cardChoice;
						this._targetChoice=this._backup._targetChoice;
						this._skillChoice=this._backup._skillChoice;
					}
					delete this.skill;
				},
				isMine:function(){
					return (this.player&&this.player==game.me&&!_status.auto&&!this.player.isMad());
				},
				isOnline:function(){
					return (this.player&&this.player.isOnline());
				},
				notLink:function(){
					return this.getParent().name!='_lianhuan'&&this.getParent().name!='_lianhuan2';
				},
				addTrigger:function(skill,player){
					if(!player) return;
					var evt=this.getParent('arrangeTrigger');
					if(!evt||evt.name!='arrangeTrigger'||!evt.list) return;
					if(typeof skill=='string') skill=[skill];
					game.expandSkills(skill);
					var filter=function(content){
						if(typeof content=='string') return content==triggername;
						return content.contains(triggername);
					};
					var trigger=evt._trigger;
					var triggername=evt.triggername;
					var func=function(skillx){
						var info=lib.skill[skillx];
						var bool=false;
						for(var i in info.trigger){
							if(i!='global'&&trigger[i]!=player) continue;
							if(filter(info.trigger[i])){bool=true;break}
						}
						if(!bool) return;
						var priority=0;
						if(info.priority){
							priority=info.priority*100;
						}
						if(!lib.translate[skillx]||skillx.indexOf('_')==0||info.popup===false||info.silent){
							priority++;
						}
						var toadd=[skillx,player,priority];
						if(evt.used){
							for(var i=0;i<evt.used.length;i++){
								if(evt.used[i][0]==toadd[0]&&evt.used[i][1]==toadd[1]) return;
							}
						};
						for(var i=0;i<evt.list.length;i++){
							if(evt.list[i][0]==toadd[0]&&evt.list[i][1]==toadd[1]) return;
						}
						evt.list.add(toadd);
						evt.list.sort(function(a,b){
							return b[2]-a[2];
						});
					}
					for(var j=0;j<skill.length;j++){
						func(skill[j]);
					}
				},
				trigger:function(name){
					if(_status.video) return;
					if(name==='gameStart'){
						if(_status.brawl&&_status.brawl.gameStart){
							_status.brawl.gameStart();
						}
						if(lib.config.show_cardpile){
							ui.cardPileButton.style.display='';
						}
						_status.gameStarted=true;
						game.showHistory();
					}
					if(!lib.hookmap[name]&&!lib.config.compatiblemode) return;
					if(!game.players||!game.players.length) return;
					var event=this;
					var start=event.player||game.me||game.players[0];
					if(!game.players.contains(start)){
						start=game.findNext(start);
					}
					var list=[];
					var roles=['player','source','target'];
					var listAdded;
					var addList=function(skill,player){
						if(listAdded[skill]) return;
						if(player.forbiddenSkills[skill]) return;
						if(player.disabledSkills[skill]) return;
						listAdded[skill]=true;
						var info=lib.skill[skill];
						var num=0;
						if(info.priority){
							num=info.priority*100;
						}
						if(!lib.translate[skill]||skill.indexOf('_')==0||info.popup===false||info.silent){
							num++;
						}
						list.push([skill,player,num]);
					};
					var totalPopulation=game.players.length+game.dead.length+1;
					var player=start;
					var globalskill='global_'+name;
					var map=_status.connectMode?lib.playerOL:game.playerMap;
					for(var iwhile=0;iwhile<totalPopulation;iwhile++){
						listAdded={};
						for(var j in player.tempSkills){
							var expire=player.tempSkills[j];
							if(expire===name||
								(Array.isArray(expire)&&expire.contains(name))||
								(typeof expire==='function'&&expire(event,player,name))){
								delete player.tempSkills[j];
								player.removeSkill(j);
							}
							else if(get.objtype(expire)==='object'){
								for(var i=0;i<roles.length;i++){
									if(expire[roles[i]]&&player===event[roles[i]]&&
										(expire[roles[i]]===name||(Array.isArray(expire[roles[i]])&&expire[roles[i]].contains(name)))){
										delete player.tempSkills[j];
										player.removeSkill(j);
									}
								}
							}
						}
						if(lib.config.compatiblemode){
							(function(){
								var skills=player.getSkills(true).concat(lib.skill.global);
								game.expandSkills(skills);
								for(var i=0;i<skills.length;i++){
									var trigger=get.info(skills[i]).trigger;
									if(trigger){
										var add=false;
										if(player===event.player&&trigger.player){
											if(typeof trigger.player==='string'){
												if(trigger.player===name) add=true;
											}
											else if(trigger.player.contains(name)) add=true;
										}
										if((player===event.target||
											(event.multitarget&&event.targets&&event.targets.contains(player)))&&
											trigger.target){
											if(typeof trigger.target==='string'){
												if(trigger.target===name) add=true;
											}
											else if(trigger.target.contains(name)) add=true;
										}
										if(player===event.source&&trigger.source){
											if(typeof trigger.source==='string'){
												if(trigger.source===name) add=true;
											}
											else if(trigger.source.contains(name)) add=true;
										}
										if(trigger.global){
											if(typeof trigger.global==='string'){
												if(trigger.global===name) add=true;
											}
											else if(trigger.global.contains(name)) add=true;
										}
										if(add){
											addList(skills[i],player);
										}
									}
								}
							}());
						}
						else{
							for(var i=0;i<roles.length;i++){
								if(event[roles[i]]===player){
									var triggername=player.playerid+'_'+roles[i]+'_'+name;
									if(lib.hook[triggername]){
										for(var j=0;j<lib.hook[triggername].length;j++){
											addList(lib.hook[triggername][j],player);
										}
									}
									triggername=roles[i]+'_'+name;
									if(lib.hook.globalskill[triggername]){
										for(var j=0;j<lib.hook.globalskill[triggername].length;j++){
											addList(lib.hook.globalskill[triggername][j],player);
										}
									}
								}
							}
							if(lib.hook.globalskill[globalskill]){
								for(var j=0;j<lib.hook.globalskill[globalskill].length;j++){
									addList(lib.hook.globalskill[globalskill][j],player);
								}
							}
							for(var i in lib.hook.globaltrigger[name]){
								if(map[i]===player){
									for(var j=0;j<lib.hook.globaltrigger[name][i].length;j++){
										addList(lib.hook.globaltrigger[name][i][j],map[i]);
									}
								}
							}
						}
						player=player.next;
						if(!player||player===start){
							break;
						}
					}
					list.sort(function(a,b){
						return b[2]-a[2];
					});
					if(list.length){
						var next=game.createEvent('arrangeTrigger',false,event);
						next.setContent('arrangeTrigger');
						next.list=list;
						next._trigger=event;
						next.triggername=name;
						//next.starter=start;
						event._triggering=next;
					}
				},
				untrigger:function(all,player){
					var evt=this._triggering;
					if(all){
						if(evt&&evt.list) evt.list.length=0;
						this._triggered=5;
					}
					else{
						if(player){
							this._notrigger.add(player);
						}
						if(evt&&evt.list){
							for(var i=0;i<evt.list.length;i++){
								if(evt.list[i][1]==player) evt.list.splice(i--,1);
							}
						}
					}
				},
			},
			dialog:{
				add:function(item,noclick,zoom){
					if(typeof item=='string'){
						if(item.indexOf('###')==0){
							var items=item.slice(3).split('###');
							this.add(items[0],noclick,zoom);
							this.addText(items[1],noclick,zoom);
						}
						else if(noclick){
							var strstr=item;
							item=ui.create.div('',this.content);
							item.innerHTML=strstr;
						}
						else{
							item=ui.create.caption(item,this.content);
						}
					}
					else if(get.objtype(item)=='div'){
						this.content.appendChild(item);
					}
					else if(get.itemtype(item)=='cards'){
						var buttons=ui.create.div('.buttons',this.content);
						if(zoom) buttons.classList.add('smallzoom');
						this.buttons=this.buttons.concat(ui.create.buttons(item,'card',buttons,noclick));
					}
					else if(get.itemtype(item)=='players'){
						var buttons=ui.create.div('.buttons',this.content);
						if(zoom) buttons.classList.add('smallzoom');
						this.buttons=this.buttons.concat(ui.create.buttons(item,'player',buttons,noclick));
					}
					else{
						var buttons=ui.create.div('.buttons',this.content);
						if(zoom) buttons.classList.add('smallzoom');
						this.buttons=this.buttons.concat(ui.create.buttons(item[0],item[1],buttons,noclick));
					}
					if(this.buttons.length) {
						if(this.forcebutton!==false) this.forcebutton=true;
						if(this.buttons.length>3||(zoom&&this.buttons.length>5)){
							this.classList.remove('forcebutton-auto');
						}
						else{
							this.classList.add('forcebutton-auto');
						}
					}
					ui.update();
					return item;
				},
				addText:function(str,center){
					if(center!==false){
						this.add('<div class="text center">'+str+'</div>');
					}
					else{
						this.add('<div class="text">'+str+'</div>');
					}
					return this;
				},
				addSmall:function(item,noclick){
					return this.add(item,noclick,true);
				},
				addAuto:function(content){
					if(content&&content.length>4&&!this._hovercustomed){
						this.addSmall(content);
					}
					else{
						this.add(content);
					}
				},
				open:function(){
					if(this.noopen) return;
					for(var i=0;i<ui.dialogs.length;i++){
						if(ui.dialogs[i]==this){
							this.show();
							this.refocus();
							ui.dialogs.remove(this);
							ui.dialogs.unshift(this);
							ui.update();
							return this;
						}
						if(ui.dialogs[i].static) ui.dialogs[i].unfocus();
						else ui.dialogs[i].hide();
					}
					ui.dialog=this;
					var translate;
					if(lib.config.remember_dialog&&lib.config.dialog_transform&&!this.classList.contains('fixed')){
						translate=lib.config.dialog_transform;
						this._dragtransform=translate;
						this.style.transform='translate('+translate[0]+'px,'+translate[1]+'px) scale(0.8)';
					}
					else{
						this.style.transform='scale(0.8)';
					}
					this.style.transitionProperty='opacity,transform';
					this.style.opacity=0;
					ui.arena.appendChild(this);
					ui.dialogs.unshift(this);
					ui.update();
					ui.refresh(this);
					if(lib.config.remember_dialog&&lib.config.dialog_transform&&!this.classList.contains('fixed')){
						this.style.transform='translate('+translate[0]+'px,'+translate[1]+'px) scale(1)';
					}
					else{
						this.style.transform='scale(1)';
					}
					this.style.opacity=1;
					var that=this;
					setTimeout(function(){
						that.style.transitionProperty='';
					},500);
					return this;
				},
				close:function(){
					ui.dialogs.remove(this);
					this.delete();
					if(ui.dialogs.length>0){
						ui.dialog=ui.dialogs[0];
						ui.dialog.show();
						ui.dialog.refocus();
						ui.update();
					}
					// if(ui.arenalog){
					// 	ui.arenalog.classList.remove('withdialog');
					// }
					return this;
				},
				setCaption:function(str){
					this.querySelector('.caption').innerHTML=str;
					return this;
				},
			},
			control:{
				open:function(){
					ui.control.insertBefore(this,_status.createControl||ui.confirm);
					ui.controls.unshift(this);
					if(this.childNodes.length){
						this.style.transition='opacity 0.5s';
						ui.refresh(this);
						this.style.transform='translateX(-'+(this.offsetWidth/2)+'px)';
						this.style.opacity=1;
						ui.refresh(this);
						this.style.transition='';
					}
					else{
						this.animate('controlpressdownx',500);
					}
					ui.updatec();
					return this;
				},
				add:function(item){
					var node=document.createElement('div');
					this.appendChild(node);
					node.link=item;
					node.innerHTML=get.translation(item);
					node.addEventListener(lib.config.touchscreen?'touchend':'click',ui.click.control);
				},
				close:function(){
					this.animate('controlpressdownx',500);
	
					ui.controls.remove(this);
					this.delete();
	
					setTimeout(ui.updatec,100);
	
	
					if(ui.confirm==this) delete ui.confirm;
					if(ui.skills==this) delete ui.skills;
					if(ui.skills2==this) delete ui.skills2;
					if(ui.skills3==this) delete ui.skills3;
				},
				replace:function(){
					// this.animate('controlpressdownx',500);
					if(this.replaceTransition===false){
						this.style.transitionProperty='none';
						ui.refresh(this);
					}
	
					while(this.childNodes.length) this.firstChild.remove();
					var i,controls;
					if(Array.isArray(arguments[0])) controls=arguments[0];
					else controls=arguments;
					delete this.custom;
					for(i=0;i<controls.length;i++){
						if(typeof controls[i]=='function'){
							this.custom=controls[i];
						}
						else{
							this.add(controls[i]);
						}
					}
					if(this.childNodes.length){
						var width=0;
						for(i=0;i<this.childNodes.length;i++) width+=this.childNodes[i].offsetWidth;
						ui.refresh(this);
						this.style.width=width+'px';
					}
					ui.updatec();
					if(this.replaceTransition===false){
						var that=this;
						setTimeout(function(){
							that.style.transitionProperty='';
						},200);
					}
					return this;
				},
			},
			client:{
				send:function(){
					if(this.closed) return this;
					var args=Array.from(arguments);
					if(typeof args[0]=='function'){
						args.unshift('exec');
					}
					for(var i=1;i<args.length;i++){
						args[i]=get.stringifiedResult(args[i]);
					}
					try{
						this.ws.send(JSON.stringify(args));
					}
					catch(e){
						this.ws.close();
					}
					return this;
				},
				close:function(){
					lib.node.clients.remove(this);
					lib.node.observing.remove(this);
					if(ui.removeObserve&&!lib.node.observing.length){
						ui.removeObserve.remove();
						delete ui.removeObserve;
					}
					this.closed=true;
					if(_status.waitingForPlayer){
						for(var i=0;i<game.connectPlayers.length;i++){
							if(game.connectPlayers[i].playerid==this.id){
								game.connectPlayers[i].uninitOL();
								delete game.connectPlayers[i].playerid;
							}
						}
						if(game.onlinezhu==this.id){
							game.onlinezhu=null;
						}
						game.updateWaiting();
					}
					else if(lib.playerOL[this.id]){
						var player=lib.playerOL[this.id];
						player.setNickname(player.nickname+' - 离线');
						game.broadcast(function(player){
							player.setNickname(player.nickname+' - 离线');
						},player);
						player.unwait('ai');
					}
	
					if(window.isNonameServer){
						document.querySelector('#server_count').innerHTML=lib.node.clients.length;
					}
					return this;
				},
			},
			nodews:{
				send:function(message){
					game.send('server','send',this.wsid,message);
				},
				on:function(type,func){
					this['on'+type]=func;
				},
				close:function(){
					game.send('server','close',this.wsid);
				},
			},
			ws:{
				onopen:function(){
					if(_status.connectCallback){
						_status.connectCallback(true);
						delete _status.connectCallback;
					}
				},
				onmessage:function(messageevent){
					if(messageevent.data=='heartbeat'){
						this.send('heartbeat');
						return;
					}
					var message;
					try{
						message=JSON.parse(messageevent.data);
						if(!Array.isArray(message)||
							typeof lib.message.client[message[0]]!=='function'){
							throw('err');
						}
						for(var i=1;i<message.length;i++){
							message[i]=get.parsedResult(message[i]);
						}
					}
					catch(e){
						console.log(e);
						console.log('invalid message: '+messageevent.data);
						return;
					}
					lib.message.client[message.shift()].apply(null,message);
				},
				onerror:function(e){
					if(this._nocallback) return;
					if(_status.connectCallback){
						_status.connectCallback(false);
						delete _status.connectCallback;
					}
					else{
						alert('连接失败');
					}
				},
				onclose:function(){
					if(this._nocallback) return;
					if(_status.connectCallback){
						_status.connectCallback(false);
						delete _status.connectCallback;
					}
					if(game.online||game.onlineroom){
						if((game.servermode||game.onlinehall)&&_status.over){
	
						}
						else{
							localStorage.setItem(lib.configprefix+'directstart',true);
							game.reload();
						}
					}
					else{
						// game.saveConfig('reconnect_info');
					}
					game.online=false;
					game.ws=null;
				},
			}
		},
		card:{
			list:any[];
		},
		filter:{
			all:function(){
				return true;
			},
			buttonIncluded:function(button){
				return !(_status.event.excludeButton&&_status.event.excludeButton.contains(button));
			},
			filterButton:function(button){
				return true;
			},
			filterTrigger:function(event,player,name,skill){
				if(player._hookTrigger){
					for(var i=0;i<player._hookTrigger.length;i++){
						var info=lib.skill[player._hookTrigger[i]].hookTrigger;
						if(info){
							if(info.block&&info.block(event,player,name,skill)){
								return false;
							}
						}
					}
				}
				var info=get.info(skill);
				if(info.filter&&!info.filter(event,player,name)){
					return false;
				}
				if(event._notrigger.contains(player)&&!lib.skill.global.contains(skill)){
					return false;
				}
				if(typeof info.usable=='number'&&player.hasSkill('counttrigger')&&
					player.storage.counttrigger&&player.storage.counttrigger[skill]>=info.usable){
					return false;
				}
				if(info.round&&(info.round-(game.roundNumber-player.storage[skill+'_roundcount'])>0)){
					return false;
				}
				return true;
			},
			characterDisabled:function(i,libCharacter){
				if(lib.character[i][4]&&lib.character[i][4].contains('forbidai')) return true;
				if(lib.character[i][4]&&lib.character[i][4].contains('unseen')) return true;
				if(lib.config.forbidai.contains(i)) return true;
				if(lib.characterFilter[i]&&!lib.characterFilter[i](get.mode())) return true;
				if(_status.connectMode){
					if(lib.configOL.banned.contains(i)) return true;
					var double_character=false;
					if(lib.configOL.mode=='guozhan'){
						double_character=true;
					}
					else if(lib.configOL.double_character&&(lib.configOL.mode=='identity'||lib.configOL.mode=='stone')){
						double_character=true;
					}
					else if(lib.configOL.double_character_jiange&&(lib.configOL.mode=='versus'&&_status.mode=='jiange')){
						double_character=true;
					}
					if(double_character&&lib.config.forbiddouble.contains(i)){
						return true;
					}
					// if(lib.configOL.ban_weak){
					// 	if(lib.config.replacecharacter[i]&&libCharacter&&libCharacter[lib.config.replacecharacter[i]]) return true;
					// 	if(lib.config.forbidall.contains(i)) return true;
					// 	if(!double_character&&get.rank(i,true)<=2){
					// 		return true;
					// 	}
					// }
					// if(lib.configOL.ban_strong&&get.rank(i,true)>=8){
					// 	return true;
					// }
				}
				else{
					if(lib.config.banned.contains(i)) return true;
					var double_character=false;
					if(get.mode()=='guozhan'){
						double_character=true;
					}
					else if(get.config('double_character')&&(lib.config.mode=='identity'||lib.config.mode=='stone')){
						double_character=true;
					}
					else if(get.config('double_character_jiange')&&(lib.config.mode=='versus'&&_status.mode=='jiange')){
						double_character=true;
					}
					if(double_character&&lib.config.forbiddouble.contains(i)){
						return true;
					}
					// if(get.config('ban_weak')){
					// 	if(lib.config.replacecharacter[i]&&lib.character[lib.config.replacecharacter[i]]) return true;
					// 	if(lib.config.forbidall.contains(i)) return true;
					// 	if(!double_character&&get.rank(i,true)<=2){
					// 		return true;
					// 	}
					// }
					// if(get.config('ban_strong')&&get.rank(i,true)>=8){
					// 	return true;
					// }
				}
			},
			characterDisabled2:function(i){
				var info=lib.character[i];
				if(info[4]){
					if(info[4].contains('boss')) return true;
					if(info[4].contains('hiddenboss')) return true;
					if(info[4].contains('minskin')) return true;
					if(info[4].contains('unseen')) return true;
					if(info[4].contains('forbidai')&&!_status.event.isMine()) return true;
					if(lib.characterFilter[i]&&!lib.characterFilter[i](get.mode())) return true;
				}
				return false;
			},
			skillDisabled:function(skill){
				if(!lib.translate[skill]||!lib.translate[skill+'_info']) return true;
				var info=lib.skill[skill];
				if(info&&!info.unique&&!info.temp&&!info.sub&&!info.fixed&&!info.vanish){
					return false;
				}
				return true;
			},
			cardEnabled:function(card,player,event){
				card=get.autoViewAs(card,null,player);
				if(player==undefined) player=_status.event.player;
				if(event==='forceEnable'){
					var mod=game.checkMod(card,player,'unchanged','cardEnabled',player);
					if(mod!='unchanged') return mod;
					return true;
				}
				else{
					var filter=get.info(card).enable;
					if(!filter) return;
					var mod=game.checkMod(card,player,'unchanged','cardEnabled',player);
					if(mod!='unchanged') return mod;
					if(typeof filter=='boolean') return filter;
					if(typeof filter=='function') return filter(card,player,event);
				},
			},
			cardRespondable:function(card,player,event){
				event=event||_status.event;
				if(event.name!='chooseToRespond') return true;
				var source=event.getParent().player;
				if(source!=player){
					if(source.hasSkillTag('norespond',false,[card,player,event],true)){
						return false;
					}
				}
				if(player==undefined) player=_status.event.player;
				var mod=game.checkMod(card,player,'unchanged','cardRespondable',player);
				if(mod!='unchanged') return mod;
				return true;
			},
			cardUsable:function(card,player,event){
				card=get.autoViewAs(card,null,player);
				if(player!=_status.event.player) return true;
				event=event||_status.event;
				if(event.getParent().name!='phaseUse') return true;
				if(event.getParent().player!=player) return true;
				var num=get.info(card).usable;
				if(typeof num=='function') num=num(card,player);
				num=game.checkMod(card,player,num,'cardUsable',player);
				if(typeof num!='number') return true;
				else return(player.countUsed(card)<num);
			},
			cardDiscardable:function(card,player,event){
				event=event||_status.event;
				var mod=game.checkMod(card,player,event.getParent().name,'unchanged','cardDiscardable',player);
				if(mod!='unchanged') return mod;
				return true;
			},
			canBeDiscarded:function(card,player,target,event){
				event=event||_status.event;
				var mod=game.checkMod(card,player,target,event.getParent().name,'unchanged','canBeDiscarded',target);
				if(mod!='unchanged') return mod;
				return true;
			},
			canBeGained:function(card,player,target,event){
				event=event||_status.event;
				var mod=game.checkMod(card,player,target,event.getParent().name,'unchanged','canBeGained',target);
				if(mod!='unchanged') return mod;
				return true;
			},
			cardAiIncluded:function(card){
				if(_status.event.isMine()) return true;
				return (_status.event._aiexclude.contains(card)==false);
			},
			filterCard:function(card,player,event){
				if(get.info(card).toself&&!lib.filter.targetEnabled(card,player,player)) return false;
				return (lib.filter.cardEnabled(card,player,event)&&
					lib.filter.cardUsable(card,player,event));
			},
			targetEnabled:function(card,player,target){
				if(!card) return false;
				var info=get.info(card);
				var filter=info.filterTarget;
				var mod=game.checkMod(card,player,target,'unchanged','playerEnabled',player);
				if(mod==false) return false;
				if(!info.singleCard||ui.selected.targets.length==0){
					var mod=game.checkMod(card,player,target,'unchanged','targetEnabled',target);
					if(mod!='unchanged') return mod;
				}
				if(typeof filter=='boolean') return filter;
				if(typeof filter=='function') return filter(card,player,target);
			},
			targetEnabled2:function(card,player,target){
				if(lib.filter.targetEnabled(card,player,target)) return true;
				if(!card) return false;
	
				if(game.checkMod(card,player,target,'unchanged','playerEnabled',player)==false) return false;
				if(game.checkMod(card,player,target,'unchanged','targetEnabled',target)==false) return false;
	
				var filter=get.info(card).modTarget;
				if(typeof filter=='boolean') return filter;
				if(typeof filter=='function') return filter(card,player,target);
				return false;
			},
			targetEnabled3:function(card,player,target){
				if(!card) return false;
				var info=get.info(card);
	
				if(info.filterTarget==true) return true;
				if(typeof info.filterTarget=='function'&&info.filterTarget(card,player,target)) return true;
	
				if(info.modTarget==true) return true;
				if(typeof info.modTarget=='function'&&info.modTarget(card,player,target)) return true;
				return false;
			},
			targetInRange:function(card,player,target){
				var mod=game.checkMod(card,player,target,'unchanged','targetInRange',player);
				var extra=0;
				if(mod!='unchanged'){
					if(typeof mod=='boolean') return mod;
					if(typeof mod=='number') extra=mod;
				}
				var info=get.info(card);
				var range=info.range;
				var outrange=info.outrange;
				if(range==undefined&&outrange==undefined) return true;
				
				for(var i in range){
					var distance=get.distance(player,target,i)+extra;
					if(range[i]<distance) return false;
				}
				for(var i in outrange){
					var distance=get.distance(player,target,i)+extra;
					if(outrange[i]>distance) return false;
				}
				return true;
			},
			filterTarget:function(card,player,target){
				return (lib.filter.targetEnabled(card,player,target)&&
					lib.filter.targetInRange(card,player,target));
			},
			filterTarget2:function(card,player,target){
				return (lib.filter.targetEnabled2(card,player,target)&&
					lib.filter.targetInRange(card,player,target));
			},
			notMe:function(card,player,target){
				return player!=target;
			},
			isMe:function(card,player,target){
				return player==target;
			},
			attackFrom:function(card,player,target){
				return get.distance(player,target,'attack')<=1;
			},
			globalFrom:function(card,player,target){
				return get.distance(player,target)<=1;
			},
			selectCard:function(){
				return [1,1];
			},
			selectTarget:function(){
				var card=get.card(),player=get.player();
				if(card==undefined) return;
				var range;
				var select=get.info(card).selectTarget;
				if(select==undefined){
					if(get.info(card).filterTarget==undefined) return[0,0];
					range=[1,1];
				}
				else if(typeof select=='number') range=[select,select];
				else if(get.itemtype(select)=='select') range=select;
				else if(typeof select=='function') range=select(card,player);
				game.checkMod(card,player,range,'selectTarget',player);
				return range;
			},
			judge:function(card,player,target){
				var judges=target.getCards('j');
				for(var i=0;i<judges.length;i++){
					if((judges[i].viewAs||judges[i].name)==card.name) return false;
				}
				return true;
			},
			autoRespondSha:function(){
				return !this.player.hasSha(true);
			},
			autoRespondShan:function(){
				return !this.player.hasShan();
			},
			wuxieSwap:function(event){
				if(event.type=='wuxie'){
					if(ui.wuxie&&ui.wuxie.classList.contains('glow')){
						return true;
					}
					if(ui.tempnowuxie&&ui.tempnowuxie.classList.contains('glow')&&event.state>0){
						var triggerevent=event.getTrigger();
						if(triggerevent){
							if(ui.tempnowuxie._origin==triggerevent.parent.id){
								return true;
							}
						}
						else if(ui.tempnowuxie._origin==_status.event.id2){
							return true;
						}
					}
					if(!_status.connectMode&&lib.config.wuxie_self&&event.getParent().state){
						var tw=event.getTrigger().parent;
						if(tw.player.isUnderControl(true)&&!tw.player.hasSkillTag('noautowuxie')&&
							tw.targets&&tw.targets.length==1&&!tw.noai){
							return true;
						}
					}
				}
			},
		},
		sort:{
			character:function(a,b){
				var groupSort=function(name){
					if(!lib.character[name]) return 4;
					if(lib.character[name][1]=='shen') return -1;
					if(lib.character[name][1]=='wei') return 0;
					if(lib.character[name][1]=='shu') return 1;
					if(lib.character[name][1]=='wu') return 2;
					if(lib.character[name][1]=='qun') return 3;
					if(lib.character[name][1]=='western') return 4;
					return 5;
				}
				var del=groupSort(a)-groupSort(b);
				if(del!=0) return del;
				var aa=a,bb=b;
				if(a.indexOf('_')!=-1){
					a=a.slice(a.indexOf('_')+1);
				}
				if(b.indexOf('_')!=-1){
					b=b.slice(b.indexOf('_')+1);
				}
				if(a!=b){
					return a>b?1:-1;
				}
				return aa>bb?1:-1;
			},
			card:function(a,b){
				var typeSort=function(name){
					var type=get.type(name);
					if(!type) return 10;
					if(type=='basic') return -1;
					if(type=='trick') return 0;
					if(type=='delay') return 1;
					if(type=='equip'){
						var type2=get.subtype(name);
						if(type2&&type2.slice) return 1+parseInt(type2.slice(5)||7);
						return 8.5
					}
					return 9;
				}
				var del=typeSort(a)-typeSort(b);
				if(del!=0) return del;
				var aa=a,bb=b;
				if(a.indexOf('_')!=-1){
					a=a.slice(a.indexOf('_')+1);
				}
				if(b.indexOf('_')!=-1){
					b=b.slice(b.indexOf('_')+1);
				}
				if(a!=b){
					return a>b?1:-1;
				}
				return aa>bb?1:-1;
			},
			random:function(){
				return (Math.random()-0.5);
			},
			seat:function(a,b){
				var player=lib.tempSortSeat||_status.event.player;
				var delta=get.distance(player,a,'absolute')-get.distance(player,b,'absolute');
				if(delta) return delta;
				delta=parseInt(a.dataset.position)-parseInt(b.dataset.position);
				if(player.side==game.me.side) return delta;
				return -delta;
			},
			position:function(a,b){
				return parseInt(a.dataset.position)-parseInt(b.dataset.position);
			},
			priority:function(a,b){
				var i1=get.info(a[0]),i2=get.info(b[0]);
				if(i1.priority==undefined) i1.priority=0;
				if(i2.priority==undefined) i2.priority=0;
				if(i1.priority==i2.priority){
					if(i1.forced==undefined&&i2.forced==undefined) return 0;
					if(i1.forced&&i2.forced) return 0;
					if(i1.forced) return 1;
					if(i2.forced) return -1;
				}
				return i2.priority-i1.priority;
			},
			number:function(a,b){
				return get.number(a)-get.number(b);
			},
			number2:function(a,b){
				return get.number(b)-get.number(a);
			},
			capt:function(a,b){
				var aa=a,bb=b;
				if(aa.indexOf('_')!=-1){
					aa=aa.slice(aa.indexOf('_')+1);
				}
				if(bb.indexOf('_')!=-1){
					bb=bb.slice(bb.indexOf('_')+1);
				}
				if(aa!=bb){
					return aa>bb?1:-1;
				}
				return a>b?1:-1;
			},
			name:function(a,b){
				if(a>b) return 1;
				if(a<b) return -1;
				return 0;
			},
		},
		skill:{
			global:any[];
			globalmap:any;
			storage:any;
			undist:any;
			others:any;
			zhu:any;
			zhuSkill:any;
			land_used:any;
			unequip:{ai:{unequip:true}},
			subplayer:{
				trigger:{player:'dieBefore'},
				forced:true,
				priority:-9,
				onremove:true,
				mark:'character',
				intro:{
					content:function(storage,player){
						if(typeof storage.intro2=='string') return storage.intro2;
						if(typeof storage.intro2=='function') return storage.intro2(storage,player);
						return '死亡前切换回主武将'
					},
					name:function(storage){
						return get.rawName(storage.name);
					},
				},
				content:function(){
					trigger.cancel();
					var evt=trigger.getParent('damage');
					if(evt.player==player){
						evt.untrigger(false,player);
					}
					player.exitSubPlayer(true);
				},
				ai:{
					nosave:true
				}
			},
			autoswap:{
				trigger:{player:['playercontrol','chooseToUseBegin','chooseToRespondBegin','chooseToDiscardBegin','chooseToCompareBegin',
				'chooseButtonBegin','chooseCardBegin','chooseTargetBegin','chooseCardTargetBegin','chooseControlBegin',
				'chooseBoolBegin','choosePlayerCardBegin','discardPlayerCardBegin','gainPlayerCardBegin']},
				forced:true,
				priority:100,
				popup:false,
				filter:function(event,player){
					if(event.autochoose&&event.autochoose()) return false;
					if(lib.filter.wuxieSwap(event)) return false;
					if(_status.auto||!player.isUnderControl()) return false;
					return true;
				},
				content:function(){
					game.modeSwapPlayer(player);
				},
			},
			dualside:{
				subSkill:{
					turn:{
						trigger:{player:['turnOverAfter','dieBefore']},
						silent:true,
						filter:function(event,player){
							if(player.storage.dualside_over) return false;
							return Array.isArray(player.storage.dualside);
						},
						content:function(){
							var cfg=player.storage.dualside;
							var bool=player.isTurnedOver();
							if(trigger.name=='die'){
								bool=!bool;
							}
							if(bool){
								cfg[1]=player.hp;
								cfg[2]=player.maxHp;
								player.reinit(cfg[0],cfg[3],[cfg[4],cfg[5]]);
								player.unmarkSkill('dualside');
								player.markSkillCharacter('dualside',{name:cfg[0]},'正面','当前体力：'+cfg[1]+'/'+cfg[2]);
							}
							else{
								cfg[4]=player.hp;
								cfg[5]=player.maxHp;
								player.reinit(cfg[3],cfg[0],[cfg[1],cfg[2]]);
								player.unmarkSkill('dualside');
								player.markSkillCharacter('dualside',{name:cfg[3]},'背面','当前体力：'+cfg[4]+'/'+cfg[5]);
							}
	
							if(trigger.name=='die'){
								trigger.cancel();
								delete player.storage.dualside;
								player.storage.dualside_over=true;
								player.unmarkSkill('dualside');
							}
						},
					},
					init:{
						trigger:{global:'gameStart',player:'enterGame'},
						silent:true,
						content:function(){
							var list=[player.name,player.name1,player.name2];
							for(var i=0;i<list.length;i++){
								if(list[i]&&lib.character[list[i]]){
									var info=lib.character[list[i]];
									if(info[3].contains('dualside')&&info[4]){
										player.storage.dualside=[list[i],player.hp,player.maxHp];
										for(var j=0;j<info[4].length;j++){
											if(info[4][j].indexOf('dualside:')==0){
												var name2=info[4][j].slice(9);
												var info2=lib.character[name2];
												player.storage.dualside.push(name2);
												player.storage.dualside.push(get.infoHp(info2[2]));
												player.storage.dualside.push(get.infoMaxHp(info2[2]));
											}
										}
									}
								}
							}
							var cfg=player.storage.dualside;
							if(get.mode()=='guozhan'){
								if(player.name1==cfg[0]){
									player.showCharacter(0);
								}
								else{
									player.showCharacter(1);
								}
							}
							player.markSkillCharacter('dualside',{name:cfg[3]},'背面','当前体力：'+cfg[4]+'/'+cfg[5]);
						},
					}
				},
				group:['dualside_init','dualside_turn']
			},
			_disableJudge:{
				marktext:"废",
				intro:{
					content:"已经废除了判定区",
				},
				mod:{
					targetEnabled:function(card,player,target){
						if(target.storage._disableJudge&&get.type(card)=='delay') return false;
					},
				},
			},
			"_disableEquip":{
						marktext:"废",
						intro:{
							content:function(storage,player,skill){
								var str='';
								for(var i=0;i<player.storage.disableEquip.length;i++){
									str+='、'+get.translation(player.storage.disableEquip[i])+'栏';
								};
								str=str.slice(1,str.length)
								str='已经废除了'+str;
								return str;
							},
						},
						mod:{
							targetEnabled:function(card,player,target){
								if(target.isDisabled(get.subtype(card))) return false;
							},
						},
						trigger:{
							player:['disableEquipBefore','enableEquipBefore','enterGame'],
							global:'gameStart',
						},
						forced:true,
						popup:false,
						filter:function(event,player){
							return player.storage.disableEquip==undefined;
						},
						content:function(){
							player.storage.disableEquip=[];
						},
					},
			fengyin:{
				init:function(player,skill){
					var skills=player.getSkills(true,false);
					for(var i=0;i<skills.length;i++){
						if(get.is.locked(skills[i])){
							skills.splice(i--,1);
						}
					}
					player.disableSkill(skill,skills);
				},
				onremove:function(player,skill){
					player.enableSkill(skill);
				},
				locked:true,
				mark:true,
				intro:{
					content:function(storage,player,skill){
						var list=[];
						for(var i in player.disabledSkills){
							if(player.disabledSkills[i].contains(skill)){
								list.push(i)
							}
						}
						if(list.length){
							var str='失效技能：';
							for(var i=0;i<list.length;i++){
								if(lib.translate[list[i]+'_info']){
									str+=get.translation(list[i])+'、';
								}
							}
							return str.slice(0,str.length-1);
						}
					},
				}
			},
			baiban:{
				init:function(player,skill){
					var skills=player.getSkills(true,false);
					for(var i=0;i<skills.length;i++){
						if(get.skills[i]){
							skills.splice(i--,1);                                 
						} 
					}
					player.disableSkill(skill,skills);
				},
				onremove:function(player,skill){
					player.enableSkill(skill);
				},
				mark:true,
				locked:true,
				intro:{
					content:function(storage,player,skill){
						var list=[];
						for(var i in player.disabledSkills){
							if(player.disabledSkills[i].contains(skill)){
								list.push(i)
							}
						}
						if(list.length){
							var str='失效技能：';
							for(var i=0;i<list.length;i++){
								if(lib.translate[list[i]+'_info']){
									str+=get.translation(list[i])+'、';
								}
							}
							return str.slice(0,str.length-1);
						}
					},
				},
			},
			qianxing:{
				mark:true,
				nopop:true,
				init:function(player){
					game.log(player,'获得了','【潜行】');
				},
				intro:{
					content:'锁定技，你不能成为其他角色的卡牌的目标'
				},
				mod:{
					targetEnabled:function(card,player,target){
						if(player!=target) return false;
					},
				}
			},
			mianyi:{
				trigger:{player:'damageBefore'},
				mark:true,
				forced:true,
				init:function(player){
					game.log(player,'获得了','【免疫】');
				},
				content:function(){
					trigger.cancel();
				},
				ai:{
					nofire:true,
					nothunder:true,
					nodamage:true,
					effect:{
						target:function(card,player,target,current){
							if(get.tag(card,'damage')) return [0,0];
						},
					},
				},
				intro:{
					content:'防止一切伤害'
				}
			},
			mad:{
				mark:true,
				locked:true,
				intro:{
					content:'已进入混乱状态',
					name:'混乱',
					onunmark:function(storage,player){
						game.log(player,'解除混乱状态');
					},
				}
			},
			ghujia:{
				intro:{
					content:function(content,player){
						return '已有'+get.cnNumber(player.hujia)+'点护甲值';
					},
				}
			},
			counttrigger:{
				trigger:{global:'phaseAfter'},
				silent:true,
				priority:-100,
				content:function(){
					player.removeSkill('counttrigger');
					delete player.storage.counttrigger;
				},
			},
			_recovercheck:{
				trigger:{player:'recoverBefore'},
				forced:true,
				priority:100,
				popup:false,
				filter:function(event,player){
					return player.hp>=player.maxHp;
				},
				content:function(){
					trigger.cancel();
				},
			},
			_turnover:{
				trigger:{player:'phaseBefore'},
				forced:true,
				priority:100,
				popup:false,
				content:function(){
					// for(var i=0;i<game.players.length;i++){
					// 	game.players[i].in();
					// }
					if(player.isTurnedOver()){
						trigger.cancel();
						player.turnOver();
						player.phaseSkipped=true;
					}
					else{
						player.phaseSkipped=false;
					}
					if((player==_status.roundStart||_status.roundSkipped)&&!trigger.skill){
						delete _status.roundSkipped;
						game.roundNumber++;
						game.updateRoundNumber();
						for(var i=0;i<game.players.length;i++){
							if(game.players[i].isOut()&&game.players[i].outCount>0){
								game.players[i].outCount--;
								if(game.players[i].outCount==0&&!game.players[i].outSkills){
									game.players[i].in();
								}
							}
						}
						event.trigger('roundStart');
					}
				},
			},
			_usecard:{
				trigger:{global:'useCardAfter'},
				forced:true,
				popup:false,
				priority:-100,
				filter:function(event){
					return !event._cleared&&event.card.name!='wuxie';
				},
				content:function(){
					game.broadcastAll(function(){
						ui.clear();
					});
					event._cleared=true;
				},
			},
			_discard:{
				trigger:{global:'discardAfter'},
				forced:true,
				popup:false,
				priority:-100,
				filter:function(event){
					return ui.todiscard[event.discardid]?true:false;
				},
				content:function(){
					game.broadcastAll(function(id){
						var todiscard=ui.todiscard[id];
						delete ui.todiscard[id];
						if(todiscard){
							var time=1000;
							if(typeof todiscard._discardtime=='number'){
								time+=todiscard._discardtime-get.time();
							}
							if(time<0){
								time=0;
							}
							setTimeout(function(){
								for(var i=0;i<todiscard.length;i++){
									todiscard[i].delete();
								}
							},time);
						}
					},trigger.discardid);
				},
			},
			_save:{
				trigger:{source:'dying',player:'dying'},
				priority:5,
				forced:true,
				popup:false,
				filter:function(event,player){
					if(!event.player.isDying()) return false;
					if(event.source&&event.source.isIn()&&event.source!=player) return false;
					return true;
				},
				content:() => any,
			},
			_ismin:{
				mod:{
					cardEnabled:function(card,player){
						if(player.isMin()){
							if(get.type(card)=='equip') return false;
						}
					},
				}
			},
			_chongzhu:{
				enable:'phaseUse',
				logv:false,
				prompt:'将要重铸的牌置入弃牌堆并摸一张牌',
				filter:function(event,player){
					return player.hasCard(function(card){
						var info=get.info(card);
						if(typeof info.chongzhu=='function'){
							return info.chongzhu(event,player);
						}
						return info.chongzhu;
					});
				},
				filterCard:function(card){
					var info=get.info(card);
					if(typeof info.chongzhu=='function'){
						return info.chongzhu(event,_status.event.player);
					}
					return info.chongzhu;
				},
				prepare:function(cards,player){
					player.$throw(cards,1000);
				},
				check:function(card){
					// if(get.type(card)=='stonecharacter'&&_status.event.player.countCards('h',{type:'stonecharacter'})<=1){
					// 	return 0;
					// }
					return 1;
				},
				discard:false,
				delay:0.5,
				content:function(){
					"step 0"
					if(lib.config.mode=='stone'&&_status.mode=='deck'&&
					!player.isMin()&&get.type(cards[0]).indexOf('stone')==0){
						var list=get.stonecard(1,player.career);
						if(list.length){
							player.gain(game.createCard(list.randomGet()),'draw');
						}
						else{
							player.draw({drawDeck:1})
						}
					}
					else if(get.subtype(cards[0])=='spell_gold'){
						var list=get.libCard(function(info){
							return info.subtype=='spell_silver';
						});
						if(list.length){
							player.gain(game.createCard(list.randomGet()),'draw');
						}
						else{
							player.draw();
						}
					}
					else if(get.subtype(cards[0])=='spell_silver'){
						var list=get.libCard(function(info){
							return info.subtype=='spell_bronze';
						});
						if(list.length){
							player.gain(game.createCard(list.randomGet()),'draw');
						}
						else{
							player.draw();
						}
					}
					else{
						player.draw();
					}
					"step 1"
					game.cardsDiscard(cards);
				},
				ai:{
					basic:{
						order:6
					},
					result:{
						player:1,
					},
				}
			},
			_lianhuan:{
				trigger:{player:'damageAfter'},
				filter:function(event,player){
					return (event.nature&&lib.linked.contains(event.nature)&&event.player.isLinked());
				},
				forced:true,
				popup:false,
				logv:false,
				priority:-5,
				content:function(){
					"step 0"
					event.forceDie=true;
					player.link();
					event.logvid=trigger.getLogv();
					if(!trigger.notLink()) event.finish();
					"step 1"
					event.targets=game.filterPlayer(function(current){
						return current!=event.player&&current.isLinked();
					});
					lib.tempSortSeat=_status.currentPhase||player;
					event.targets.sort(lib.sort.seat);
					delete lib.tempSortSeat;
					event._args=[trigger.num,trigger.nature,trigger.cards,trigger.card];
					if(trigger.source) event._args.push(trigger.source);
					else event._args.push("nosource");
					"step 2"
					if(event.targets.length){
						var target=event.targets.shift();
						target.damage.apply(target,event._args.slice(0));
						event.redo();
					}
				},
			},
			_lianhuan2:{
				trigger:{global:'damageAfter'},
				filter:function(event,player){
					return (event.nature&&lib.linked.contains(event.nature)&&event.player.isLinked()&&
						event.player.classList.contains('dead')&&player.isLinked());
				},
				silent:true,
				popup:false,
				forced:true,
				priority:-5,
				content:function(){
					"step 0"
					event.forceDie=true;
					trigger.player.removeLink();
					if(!trigger.notLink()) event.finish();
					"step 1"
					event.targets=game.filterPlayer(function(current){
						return current.isLinked();
					});
					lib.tempSortSeat=_status.currentPhase||trigger.player;
					event.targets.sort(lib.sort.seat);
					delete lib.tempSortSeat;
					event._args=[trigger.num,trigger.nature,trigger.cards,trigger.card];
					if(trigger.source) event._args.push(trigger.source);
					else event._args.push("nosource");
					"step 2"
					if(event.targets.length){
						var target=event.targets.shift();
						target.damage.apply(target,event._args.slice(0));
						event.redo();
					}
				},
			},
			_lianhuan3:{
				trigger:{global:'damageAfter'},
				priority:-10,
				forced:true,
				popup:false,
				filter:function(event,player){
					return event.player.classList.contains('dead');
				},
				content:function(){
					trigger.player.removeLink();
				},
			},
			_lianhuan4:{
				trigger:{global:'dieAfter'},
				priority:-10,
				forced:true,
				popup:false,
				filter:function(event,player){
					return event.player.classList.contains('dead')&&event.getParent(2).name!='damage';
				},
				content:function(){
					trigger.player.removeLink();
				},
			}
		},
		character:any;
		perfectPair:any;
		cardPile:any;
		message:{
			server:{
				init:function(version,config,banned_info){
					if(lib.node.banned.contains(banned_info)){
						this.send('denied','banned');
					}
					else if(config.id&&lib.playerOL&&lib.playerOL[config.id]){
						var player=lib.playerOL[config.id];
						player.setNickname();
						player.ws=this;
						player.isAuto=false;
						this.id=config.id;
						game.broadcast(function(player){
							player.setNickname();
						},player);
						this.send('reinit',lib.configOL,get.arenaState(),game.getState?game.getState():any;game.ip,null,_status.onreconnect);
					}
					else if(version!=lib.versionOL){
						this.send('denied','version');
						lib.node.clients.remove(this);
						this.closed=true;
					}
					else if(!_status.waitingForPlayer){
						if(game.phaseNumber&&lib.configOL.observe){
							lib.node.observing.push(this);
							this.send('reinit',lib.configOL,get.arenaState(),game.getState?game.getState():any;game.ip,game.players[0].playerid);
							if(!ui.removeObserve){
								ui.removeObserve=ui.create.system('移除旁观',function(){
									lib.configOL.observe=false;
									if(game.onlineroom){
										game.send('server','config',lib.configOL);
									}
									while(lib.node.observing.length){
										lib.node.observing.shift().ws.close();
									}
									this.remove();
									delete ui.removeObserve;
								},true);
							}
						}
						else{
							this.send('denied','gaming');
							lib.node.clients.remove(this);
							this.closed=true;
						}
					}
					else if(lib.node.clients.length-(window.isNonameServer?1:0)>=parseInt(lib.configOL.number)){
						this.send('denied','number');
						lib.node.clients.remove(this);
						this.closed=true;
					}
					else{
						if(config){
							this.avatar=config.avatar;
							this.nickname=config.nickname;
						}
						for(var i=0;i<game.connectPlayers.length;i++){
							if(game.connectPlayers[i].classList.contains('unselectable2')) continue;
							if(game.connectPlayers[i]!=game.me&&!game.connectPlayers[i].playerid){
								game.connectPlayers[i].playerid=this.id;
								game.connectPlayers[i].initOL(this.nickname,this.avatar);
								game.connectPlayers[i].ws=this;
								break;
							}
						}
						this.send('init',this.id,lib.configOL,game.ip,window.isNonameServer,game.roomId);
					}
				},
				inited:function(){
					this.inited=true;
					if(_status.waitingForPlayer){
						game.updateWaiting();
					}
				},
				reinited:function(){
					this.inited=true;
				},
				result:function(result){
					var player=lib.playerOL[this.id];
					if(player){
						player.unwait(result);
					}
				},
				startGame:function(){
					if(this.id==game.onlinezhu){
						game.resume();
					}
				},
				changeRoomConfig:function(config){
					if(this.id==game.onlinezhu){
						game.broadcastAll(function(config){
							for(var i in config){
								lib.configOL[i]=config[i];
							}
							if(ui.connectStartBar){
								ui.connectStartBar.firstChild.innerHTML=get.modetrans(lib.configOL,true);
							}
						},config);
						if(lib.configOL.mode=='identity'&&lib.configOL.identity_mode=='zhong'&&game.connectPlayers){
							for(var i=0;i<game.connectPlayers.length;i++){
								game.connectPlayers[i].classList.remove('unselectable2');
							}
							lib.configOL.number=8;
							game.updateWaiting();
						}
						if(game.onlineroom){
							game.send('server','config',lib.configOL);
						}
						for(var i=0;i<game.connectPlayers.length;i++){
							if(game.connectPlayers[i].playerid==this.id){
								game.connectPlayers[i].chat('房间设置已更改');
							}
						}
					}
				},
				changeNumConfig:function(num,index,bool){
					if(this.id==game.onlinezhu){
						lib.configOL.number=num;
						game.send('server','config',lib.configOL);
						if(game.connectPlayers&&game.connectPlayers[index]){
							if(bool){
								game.connectPlayers[index].classList.add('unselectable2');
							}
							else{
								game.connectPlayers[index].classList.remove('unselectable2');
							}
							game.updateWaiting();
						}
					}
				},
				chat:function(id,str){
					var player;
					if(lib.playerOL[id]){
						player=lib.playerOL[id];
					}
					else if(game.connectPlayers){
						for(var i=0;i<game.connectPlayers.length;i++){
							if(game.connectPlayers[i].playerid==id){
								player=game.connectPlayers[i];break;
							}
						}
					}
					if(player) lib.element.player.chat.call(player,str);
				},
				giveup:function(player){
					_status.event.next.length=0;
					game.createEvent('giveup',false).setContent(function(){
						game.log(player,'投降');
						player.popup('投降');
						player.die('nosource');
					}).player=player;
				},
				auto:function(){
					var player=lib.playerOL[this.id];
					if(player){
						player.isAuto=true;
						player.setNickname(player.nickname+' - 托管');
						game.broadcast(function(player){
							player.setNickname(player.nickname+' - 托管');
						},player);
					}
				},
				unauto:function(){
					var player=lib.playerOL[this.id];
					if(player){
						player.isAuto=false;
						player.setNickname(player.nickname);
						game.broadcast(function(player){
							player.setNickname(player.nickname);
						},player);
					}
				},
				exec:function(func){
					// if(typeof func=='function'){
					//     var args=Array.from(arguments);
					//     args.shift();
					//     func.apply(this,args);
					// }
				},
				log:function(){
					var items=[];
					try{
						for(var i=0;i<arguments.length;i++){
							eval('items.push('+arguments[i]+')');
						}
					}
					catch(e){
						this.send('log',['err']);
						return;
					}
					this.send('log',items);
				},
			},
			client:{
				log:function(arr){
					if(Array.isArray(arr)){
						for(var i=0;i<arr.length;i++){
							console.log(arr[i]);
						}
					}
				},
				opened:function(){
					game.send('init',lib.versionOL,{
						id:game.onlineID,
						avatar:lib.config.connect_avatar,
						nickname:lib.config.connect_nickname
					},lib.config.banned_info);
					if(ui.connecting&&!ui.connecting.splashtimeout){
						ui.connecting.firstChild.innerHTML='重连成功';
					}
				},
				onconnection:function(id){
					var ws={wsid:id};
					for(var i in lib.element.nodews){
						ws[i]=lib.element.nodews[i];
					}
					lib.wsOL[id]=ws;
					lib.init.connection(ws);
				},
				onmessage:function(id,message){
					if(lib.wsOL[id]){
						lib.wsOL[id].onmessage(message);
					}
				},
				onclose:function(id){
					if(lib.wsOL[id]){
						lib.wsOL[id].onclose();
					}
				},
				selfclose:function(){
					if(game.online||game.onlineroom){
						if((game.servermode||game.onlinehall)&&_status.over){
							// later
						}
						else{
							game.saveConfig('tmp_user_roomId');
						}
					}
					game.ws.close();
				},
				reloadroom:function(forced){
					if(window.isNonameServer&&(forced||!_status.protectingroom)){
						game.reload();
					}
				},
				createroom:function(index,config,mode){
					game.online=false;
					game.onlineroom=true;
					game.roomId=index;
					lib.node={};
					if(config&&mode&&window.isNonameServer){
						if(mode=='auto'){
							mode=lib.configOL.mode;
						}
						game.switchMode(mode,config);
					}
					else{
						game.switchMode(lib.configOL.mode);
					}
					ui.create.connecting(true);
				},
				enterroomfailed:function(){
					alert('请稍后再试');
					_status.enteringroom=false;
					ui.create.connecting(true);
				},
				roomlist:function(list,events,clients,wsid){
					game.send('server','key',game.onlineKey);
					game.online=true;
					game.onlinehall=true;
					lib.config.recentIP.remove(_status.ip);
					lib.config.recentIP.unshift(_status.ip);
					lib.config.recentIP.splice(5);
					if(!lib.config.reconnect_info||lib.config.reconnect_info[0]!=_status.ip){
						game.saveConfig('reconnect_info',[_status.ip,null]);
					}
					game.saveConfig('recentIP',lib.config.recentIP);
					_status.connectMode=true;
	
					game.clearArena();
					game.clearConnect();
					ui.pause.hide();
					ui.auto.hide();
	
					clearTimeout(_status.createNodeTimeout);
					game.send('server','changeAvatar',lib.config.connect_nickname,lib.config.connect_avatar);
	
					var proceed=function(){
						ui.rooms=[];
						game.ip=get.trimip(_status.ip);
						for(var i=0;i<list.length;i++){
							var player=ui.create.player(ui.window).animate('start');
							player.dataset.position='c'+i;
							player.classList.add('connect');
							player.roomindex=i;
							player.node.hp.classList.add('room');
							ui.rooms.push(player);
						}
						if(events){
							ui.connectRoom=ui.create.div('.forceopaque.menubutton.large.connectevents.server.pointerdiv','创建服务器',ui.window,function(){
								if(confirm('通过此选项可创建一个新房间但不加入游戏。是否继续？')){
									localStorage.setItem(lib.configprefix+'asserver','hall');
									game.reload();
								}
							});
							if(!get.config('room_button')){
								ui.connectRoom.style.display='none';
							}
	
							ui.connectEvents=ui.create.div('.forceopaque.menubutton.large.connectevents.pointerdiv','约战',ui.window,ui.click.connectEvents);
							ui.connectEventsCount=ui.create.div('.forceopaque.menubutton.icon.connectevents.highlight.hidden','',ui.window);
							ui.connectClients=ui.create.div('.forceopaque.menubutton.large.connectevents.pointerdiv.left','在线',ui.window,ui.click.connectClients);
							ui.connectClientsCount=ui.create.div('.forceopaque.menubutton.icon.connectevents.highlight.left','1',ui.window);
							if(events.length){
								ui.connectEventsCount.innerHTML=events.length;
								ui.connectEventsCount.show();
							}
						}
						game.wsid=wsid;
						lib.message.client.updaterooms(list,clients);
						lib.message.client.updateevents(events);
						ui.exitroom=ui.create.system('退出房间',function(){
							game.saveConfig('tmp_owner_roomId');
							game.saveConfig('tmp_user_roomId');
							if(ui.rooms){
								game.saveConfig('reconnect_info');
							}
							else{
								if(lib.config.reconnect_info){
									lib.config.reconnect_info.length=1;
									game.saveConfig('reconnect_info',lib.config.reconnect_info);
								}
							}
							game.reload();
						},true);
	
						if(typeof lib.config.tmp_owner_roomId=='number'){
							if(typeof game.roomId!='number'&&ui.rooms[lib.config.tmp_owner_roomId].roomempty){
								lib.configOL.mode=lib.config.connect_mode;
								game.roomId=lib.config.tmp_owner_roomId;
							}
							game.saveConfig('tmp_owner_roomId');
						}
						if(typeof lib.config.tmp_user_roomId=='number'){
							if(typeof game.roomId!='number'){
								if(!ui.rooms[lib.config.tmp_user_roomId].roomempty){
									game.roomId=lib.config.tmp_user_roomId;
								}
								else{
									ui.create.connecting();
									(function(){
										var n=10;
										var id=lib.config.tmp_user_roomId;
										var interval=setInterval(function(){
											if(n>0){
												n--;
												if(!ui.rooms[id].roomempty){
													clearInterval(interval);
													game.send('server','enter',game.roomId,lib.config.connect_nickname,lib.config.connect_avatar);
												}
											}
											else{
												ui.create.connecting(true);
												clearInterval(interval);
											}
										},500);
									}());
								}
							}
							game.saveConfig('tmp_user_roomId');
						}
	
						if(window.isNonameServer){
							var cfg='pagecfg'+window.isNonameServer;
							if(lib.config[cfg]){
								lib.configOL=lib.config[cfg][0];
								game.send('server','server',lib.config[cfg].slice(1));
								game.saveConfig(cfg);
								_status.protectingroom=true;
								setTimeout(function(){
									_status.protectingroom=false;
									if(!lib.node||!lib.node.clients||!lib.node.clients.length){
										game.reload();
									}
								},15000);
							}
							else{
								game.send('server','server');
							}
						}
						else if(typeof game.roomId=='number'){
							var room=ui.rooms[game.roomId];
							if(game.roomIdServer&&(room.serving||!room.version)){
								console.log();
								if(lib.config.reconnect_info){
									lib.config.reconnect_info[2]=null;
									game.saveConfig('reconnect_info',lib.config.reconnect_info);
								}
							}
							else{
								ui.create.connecting();
								game.send('server','enter',game.roomId,lib.config.connect_nickname,lib.config.connect_avatar);
							}
						}
						lib.init.onfree();
					}
					if(_status.event.parent){
						game.forceOver('noover',proceed);
					}
					else{
						proceed();
					}
				},
				updaterooms:function(list,clients){
					if(ui.rooms){
						ui.window.classList.add('more_room');
						var list2=['re_caocao','re_liubei','sunquan','sp_zhangjiao','re_yuanshao','dongzhuo'];
						for(var i=0;i<ui.rooms.length;i++){
							ui.rooms[i].initRoom(list[i],list2[i]);
						}
					}
					lib.message.client.updateclients(clients,true);
				},
				updateclients:function(clients,bool){
					if(clients&&ui.connectClients){
						ui.connectClients.info=clients;
						ui.connectClientsCount.innerHTML=clients.length;
					}
					if(_status.connectClientsCallback){
						_status.connectClientsCallback();
					}
				},
				updateevents:function(events){
					if(events&&ui.connectEvents){
						ui.connectEvents.info=events;
						if(events.length){
							ui.connectEventsCount.innerHTML=events.length;
							ui.connectEventsCount.show();
						}
						else{
							ui.connectEventsCount.hide();
						}
						if(_status.connectEventsCallback){
							_status.connectEventsCallback();
						}
					}
				},
				eventsdenied:function(reason){
					var str='创建约战失败';
					if(reason=='total'){
						str+='，约战总数不能超过20';
					}
					else if(reason=='time'){
						str+='，时间已过';
					}
					alert(str);
				},
				init:function(id,config,ip,servermode,roomId){
					game.online=true;
					game.onlineID=id;
					game.ip=ip;
					game.servermode=servermode;
					game.roomId=roomId;
					if(game.servermode){
						game.saveConfig('reconnect_info',[_status.ip,id,game.roomId]);
					}
					else{
						game.saveConfig('reconnect_info',[_status.ip,id]);
						game.saveConfig('tmp_user_roomId',roomId);
					}
					lib.config.recentIP.remove(_status.ip);
					lib.config.recentIP.unshift(_status.ip);
					lib.config.recentIP.splice(5);
					game.saveConfig('recentIP',lib.config.recentIP);
					_status.connectMode=true;
					lib.configOL=config;
					lib.playerOL={};
					lib.cardOL={};
	
					game.clearArena();
					game.finishCards();
					ui.create.roomInfo();
					ui.create.chat();
					if(game.servermode){
						ui.create.connectPlayers(get.modetrans(config,true));
					}
					else{
						ui.create.connectPlayers(ip);
					}
					ui.pause.hide();
					ui.auto.hide();
					game.clearConnect();
					clearTimeout(_status.createNodeTimeout);
	
					var proceed=function(){
						game.loadModeAsync(config.mode,function(mode){
							for(var i in mode.ai){
								if(typeof mode.ai[i]=='object'){
									if(ai[i]==undefined) ai[i]={};
									for(var j in mode.ai[i]){
										ai[i][j]=mode.ai[i][j];
									}
								}
								else{
									ai[i]=mode.ai[i];
								}
							}
							for(var i in mode.get){
								if(typeof mode.get[i]=='object'){
									if(get[i]==undefined) get[i]={};
									for(var j in mode.get[i]){
										get[i][j]=mode.get[i][j];
									}
								}
								else{
									get[i]=mode.get[i];
								}
							}
							for(var i in mode.translate){
								lib.translate[i]=mode.translate[i];
							}
							if(mode.game){
								game.getIdentityList=mode.game.getIdentityList;
								game.updateState=mode.game.updateState;
								game.getRoomInfo=mode.game.getRoomInfo;
							}
							if(mode.element&&mode.element.player){
								for(var i in mode.element.player){
									lib.element.player[i]=mode.element.player[i];
								}
							}
							if(mode.skill){
								for(var i in mode.skill){
									lib.skill[i]=mode.skill[i];
								}
							}
							game.finishCards();
							_status.event={
								finished:true,
								next:any[];
								after:[]
							};
							_status.paused=false;
							game.createEvent('game',false).setContent(lib.init.startOnline);
							game.loop();
							game.send('inited');
							ui.create.connecting(true);
						});
					}
					if(_status.event.parent){
						game.forceOver('noover',proceed);
					}
					else{
						proceed();
					}
					for(var i in lib.characterPack){
						for(var j in lib.characterPack[i]){
							lib.character[j]=lib.character[j]||lib.characterPack[i][j];
						}
					}
				},
				reinit:function(config,state,state2,ip,observe,onreconnect){
					ui.auto.show();
					ui.pause.show();
					game.clearConnect();
					clearTimeout(_status.createNodeTimeout);
					game.online=true;
					game.ip=ip;
					game.servermode=state.servermode;
					game.roomId=state.roomId;
					if(state.over){
						_status.over=true;
					}
					if(observe){
						game.onlineID=null;
						game.roomId=null;
					}
					if(game.servermode&&!observe){
						game.saveConfig('reconnect_info',[_status.ip,game.onlineID,game.roomId]);
					}
					else{
						game.saveConfig('reconnect_info',[_status.ip,game.onlineID]);
						if(!observe){
							game.saveConfig('tmp_user_roomId',game.roomId);
						}
					}
					_status.connectMode=true;
					lib.configOL=config;
					lib.playerOL={};
					lib.cardOL={};
	
					game.loadModeAsync(config.mode,function(mode){
						for(var i in mode.ai){
							if(typeof mode.ai[i]=='object'){
								if(ai[i]==undefined) ai[i]={};
								for(var j in mode.ai[i]){
									ai[i][j]=mode.ai[i][j];
								}
							}
							else{
								ai[i]=mode.ai[i];
							}
						}
						for(var i in mode.get){
							if(typeof mode.get[i]=='object'){
								if(get[i]==undefined) get[i]={};
								for(var j in mode.get[i]){
									get[i][j]=mode.get[i][j];
								}
							}
							else{
								get[i]=mode.get[i];
							}
						}
						for(var i in mode.translate){
							lib.translate[i]=mode.translate[i];
						}
						if(mode.game){
							game.getIdentityList=mode.game.getIdentityList;
							game.updateState=mode.game.updateState;
						}
						if(mode.element&&mode.element.player){
							for(var i in mode.element.player){
								lib.element.player[i]=mode.element.player[i];
							}
						}
						if(mode.skill){
							for(var i in mode.skill){
								lib.skill[i]=mode.skill[i];
							}
						}
						game.finishCards();
						if(mode.characterPack){
							for(var i in mode.characterPack){
								lib.characterPack[i]=mode.characterPack[i];
							}
						}
						if(mode.onreinit){
							mode.onreinit();
						}
						state=get.parsedResult(state);
						game.players=[];
						game.dead=[];
						for(var i in lib.characterPack){
							for(var j in lib.characterPack[i]){
								lib.character[j]=lib.character[j]||lib.characterPack[i][j];
							}
						}
						game.clearArena();
						game.finishCards();
						if(!observe){
							ui.create.chat();
							if(ui.exitroom){
								ui.exitroom.remove();
								delete ui.exitroom;
							}
						}
						else{
							if(!ui.exitroom){
								ui.create.system('退出旁观',function(){
									game.saveConfig('reconnect_info');
									game.reload();
								},true);
							}
							if(!lib.configOL.observe_handcard){
								ui.arena.classList.add('observe');
							}
						}
						ui.arena.setNumber(state.number);
						_status.mode=state.mode;
						var pos=state.players[observe||game.onlineID].position;
						for(var i in state.players){
							var info=state.players[i];
							var player=ui.create.player(ui.arena).animate('start');
							player.dataset.position=(info.position<pos)?info.position-pos+parseInt(state.number):info.position-pos;
							if(i==observe||i==game.onlineID){
								game.me=player;
							}
							if(player.setModeState){
								player.setModeState(info);
							}
							else{
								player.init(info.name,info.name2);
							}
							player.playerid=i;
							player.nickname=info.nickname;
							player.identity=info.identity;
							player.identityShown=info.identityShown;
							player.hp=info.hp;
							player.maxHp=info.maxHp;
							player.hujia=info.hujia;
							player.sex=info.sex;
							player.side=info.side;
							player.setNickname();
							if(info.dead){
								player.classList.add('dead');
								if(lib.config.die_move){
									player.$dieflip();
								}
								if(lib.element.player.$dieAfter){
									lib.element.player.$dieAfter.call(player);
								}
								game.dead.push(player);
							}
							else{
								game.players.push(player);
							}
							if(info.linked){
								player.addLink();
							}
							if(info.turnedover){
								player.classList.add('turnedover');
							}
	
							player.directgain(info.handcards);
							lib.playerOL[i]=player;
							for(var i=0;i<info.equips.length;i++){
								player.$equip(info.equips[i]);
							}
							for(var i=0;i<info.judges.length;i++){
								if(info.views[i]&&info.views[i]!=info.judges[i]){
									info.judges[i].classList.add('fakejudge');
									info.judges[i].viewAs=info.views[i];
									info.judges[i].node.background.innerHTML=lib.translate[info.views[i]+'_bg']||get.translation(info.views[i])[0]
								}
								player.node.judges.appendChild(info.judges[i]);
							}
							ui.updatej(player);
							if(!player.setModeState){
								if(!game.getIdentityList&&info.identityNode){
									player.node.identity.innerHTML=info.identityNode[0];
									player.node.identity.dataset.color=info.identityNode[1];
								}
								else if(player==game.me||player.identityShown||observe){
									player.setIdentity();
									player.forceShown=true;
								}
								else{
									player.setIdentity('cai');
								}
								if(!lib.configOL.observe_handcard&&(lib.configOL.mode=='identity'||lib.configOL.mode=='guozhan')){
									if(observe&&!player.identityShown){
										player.setIdentity('cai');
										player.forceShown=false;
									}
								}
							}
							player.update();
						}
						game.arrangePlayers();
						ui.create.me(true);
	
						_status.event={
							finished:true,
							next:any[];
							after:[]
						};
						_status.paused=false;
						_status.dying=get.parsedResult(state.dying)||[];
	
						if(game.updateState){
							game.updateState(state2);
						}
						var next=game.createEvent('game',false);
						next.setContent(lib.init.startOnline);
						if(observe){
							next.custom.replace.target=function(player){
								if(!lib.configOL.observe_handcard&&lib.configOL.mode=='guozhan'){
									return;
								}
								if(player.isAlive()){
									if(!game.me.identityShown&&lib.configOL.mode=='guozhan'){
										game.me.node.identity.firstChild.innerHTML='猜';
										game.me.node.identity.dataset.color='unknown';
									}
									game.swapPlayer(player);
									if(!game.me.identityShown&&lib.configOL.mode=='guozhan'){
										game.me.node.identity.firstChild.innerHTML='';
									}
								}
							}
						}
						else{
							if(Array.isArray(onreconnect)){
								onreconnect.shift().apply(this,onreconnect);
							}
						}
						game.loop();
						game.send('reinited');
						game.showHistory();
						_status.gameStarted=true;
						if(lib.config.show_cardpile){
							ui.cardPileButton.style.display='';
						}
						if(!observe&&game.me&&(game.me.isDead()||_status.over)){
							ui.create.exit();
						}
						ui.updatehl();
						ui.create.connecting(true);
					});
				},
				exec:function(func){
					if(typeof func=='function'){
						var args=Array.from(arguments);
						args.shift();
						func.apply(this,args);
					}
				},
				denied:function(reason){
					switch(reason){
						case 'version':alert('加入失败：版本不匹配');break;
						case 'gaming':alert('加入失败：游戏已开始');break;
						case 'number':alert('加入失败：房间已满');break;
						case 'banned':alert('加入失败：房间拒绝你加入');break;
						case 'key':
							alert('您的游戏版本过低，请升级到最新版');
							game.saveConfig('tmp_owner_roomId');
							game.saveConfig('tmp_user_roomId');
							game.saveConfig('reconnect_info');
							break;
						case 'offline':
						if(_status.paused&&_status.event.name=='game'){
							setTimeout(game.resume,500);
						}
						break;
					}
					game.ws.close();
					if(_status.connectDenied){
						_status.connectDenied();
					}
				},
				cancel:function(id){
					if(_status.event.id==id&&_status.event.isMine()&&_status.paused&&_status.imchoosing){
						ui.click.cancel();
						if(ui.confirm){
							ui.confirm.close();
						}
						if(_status.event.result){
							_status.event.result.id=id;
						}
					}
				},
				closeDialog:function(id){
					var dialog=get.idDialog(id);
					if(dialog){
						dialog.close();
					}
				},
				createDialog:function(id){
					var args=Array.from(arguments);
					args.shift();
					ui.create.dialog.apply(this,args).videoId=id;
				},
				gameStart:function(){
					for(var i=0;i<game.connectPlayers.length;i++){
						game.connectPlayers[i].delete();
					}
					delete game.connectPlayers;
					if(ui.connectStartButton){
						ui.connectStartButton.delete();
						delete ui.connectStartButton;
					}
					if(ui.connectStartBar){
						ui.connectStartBar.delete();
						delete ui.connectStartBar;
					}
					if(ui.roomInfo){
						ui.roomInfo.remove();
						delete ui.roomInfo;
					}
					if(ui.exitroom){
						ui.exitroom.remove();
						delete ui.exitroom;
					}
					ui.auto.show();
					ui.pause.show();
					if(lib.config.show_cardpile){
						ui.cardPileButton.style.display='';
					}
					_status.gameStarted=true;
					game.showHistory();
				},
				updateWaiting:(map) => void,
			}
		},
		suit:['club','spade','diamond','heart'],
		group:['wei','shu','wu','qun','shen'],
		nature:['fire','thunder','poison'],
        linked:['fire','thunder'],
        /** 势力配置 */
		groupnature:SMap<string>,
	
}

/** 菜单的选项的配置 */
interface SelectConfigData {
    /** 功能名 */
    name:string,
    /** 初始化时默认的选项/配置/模式 */
    init:boolean|string,
    /** 功能说明 */
    intro:string,

    restart?:boolean,
    frequent?:boolean,
    unfrequent?:boolean,
    /** 清理游戏，核心选项，应该默认是false，具体到时看代码 */
    clear?:boolean,

    nopointer?:boolean,
    input?:boolean,

    /** 二级菜单配置 */
    item?:SMap<string>,

    visualBar?:(node,item,create,switcher?) => void
    visualMenu?:(node,link,name?,config?) => void

    content?:(bool) => void

    textMenu?:(node,link) => void

    onswitch?:(bool) => void

    /** 点击触发事件（好像是有返回值的） */
    onclick?:(...) => void|boolean
}

/** 通常菜单的标准配置 */
interface CommonMenuConfigData {
    name:string,
    /** 估计是联机配置，具体要看代码 */
    connect?:{
        update:(config,map) => void,
        /** 其余配置 */
        [key:string] : SelectConfigData,
    }
	config:{
        update:(config,map) => void,
        /** 其余配置 */
        [key:string] : SelectConfigData,
    }
}

/** 扩展菜单的标准配置 */
interface ExtensionMenuConfigData {
    /** 开启 */
    enable:SelectConfigData,
    /** 功能描述 */
    intro:SelectConfigData,
    /** 隐藏此扩展 */
    hide:SelectConfigData,
    /** 其余配置 */
    [key:string] : SelectConfigData,
}

/** key为字符串的map */
export interface SMap<V> {
    [key:string] : V
}

/** key为number的map */
export interface NMap<V> {
    [key:number] : V
}

